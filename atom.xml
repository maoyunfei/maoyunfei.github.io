<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mao&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://maoyunfei.github.io/"/>
  <updated>2019-01-16T07:05:26.321Z</updated>
  <id>https://maoyunfei.github.io/</id>
  
  <author>
    <name>云逸云飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java并发编程实战———显式锁</title>
    <link href="https://maoyunfei.github.io/java/ed81c7cb/"/>
    <id>https://maoyunfei.github.io/java/ed81c7cb/</id>
    <published>2019-01-15T16:00:00.000Z</published>
    <updated>2019-01-16T07:05:26.321Z</updated>
    
    <content type="html"><![CDATA[<h3 id="lock与reentrantlock"><a class="markdownIt-Anchor" href="#lock与reentrantlock"></a> Lock与ReentrantLock</h3><p><code>Lock</code>提供了一种无条件的、可轮询的、定时的以及可中断的锁获取操作，所有加锁和解锁的方法都是显示的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lock接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code>实现了<code>Lock</code>接口，并提供了与<code>synchronized</code>相同的互斥性和内存可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ReentrantLock来保护对象状态</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">...</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//更新对象状态</span></span><br><span class="line">  <span class="comment">//捕获异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="在synchronized和reentrantlock之间进行选择"><a class="markdownIt-Anchor" href="#在synchronized和reentrantlock之间进行选择"></a> 在synchronized和ReentrantLock之间进行选择</h3><p><code>ReentrantLock</code>在加锁和内存上提供的语义与内置锁相同，此外它还提供了一些其他功能，包括定时的锁等待、可中断的锁等待、公平性，以及实现非块结构的加锁。</p><p><code>ReentrantLock</code>的危险性比同步机制要高，如果忘记在<code>finally</code>块中调用<code>unlock</code>，那么虽然代码表面上能正常运行，但实际上已经埋下隐患。</p><p>仅当内置锁不能满足需求时，才考虑使用<code>ReentrantLock</code>。</p><blockquote><p>在一些内置锁无法满足需求的情况下，<code>ReentrantLock</code>可以作为一种高级工具。当需要一些高级功能时才应该使用<code>ReentrantLock</code>，这些功能包括：可定时的、可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁。否则，还是应该优先使用<code>synchronized</code>。</p></blockquote><h3 id="读-写锁"><a class="markdownIt-Anchor" href="#读-写锁"></a> 读-写锁</h3><p><code>ReadWriteLock</code>中暴露了两个<code>Lock</code>对象，其中一个用于读操作，而另一个用于写操作。要读取由<code>ReadWriteLock</code>保护的数据，必须首先获得读取锁，当需要修改<code>ReadWriteLock</code>保护的数据时，必须首先获得写入锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReadWriteLock接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">  <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在读-写锁实现的加锁策略中，允许多个读操作同时进行，但每次只允许一个写操作。</p><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>与内置锁相比，显示的<code>Lock</code>提供了一些扩展功能，在处理锁的不可用性方面有着更高的灵活性，并且对队列有着更好的控制。但<code>ReentrantLock</code>不能完全替代<code>synchronized</code>，只有在<code>synchronized</code>无法满足需求时，才应该使用它。<br>读-写锁允许多个读线程并发地访问被保护的对象，当访问以读取操作为主的数据结构时，它能提高程序的可伸缩性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;lock与reentrantlock&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#lock与reentrantlock&quot;&gt;&lt;/a&gt; Lock与ReentrantLock&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Lock&lt;/code&gt;提供了一种无条件的、可轮询的、定时的以及可中断的锁获取操作，所有加锁和解锁的方法都是显示的。&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Lock接口&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Lock&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lockInterruptibly&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;tryLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;tryLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timeout, TimeUnit unit)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;Condition &lt;span class=&quot;title&quot;&gt;newCondition&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;实现了&lt;code&gt;Lock&lt;/code&gt;接口，并提供了与&lt;code&gt;synchronized&lt;/code&gt;相同的互斥性和内存可见性。&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用ReentrantLock来保护对象状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Lock lock = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReentrantLock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lock.lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//更新对象状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//捕获异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  lock.unlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Java Concurrency In Practice" scheme="https://maoyunfei.github.io/tags/Java-Concurrency-In-Practice/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程实战———线程池的使用</title>
    <link href="https://maoyunfei.github.io/java/7c57f4de/"/>
    <id>https://maoyunfei.github.io/java/7c57f4de/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2019-01-01T10:13:54.627Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在任务与执行策略之间的隐形耦合"><a class="markdownIt-Anchor" href="#在任务与执行策略之间的隐形耦合"></a> 在任务与执行策略之间的隐形耦合</h3><blockquote><p>在一些任务中，需要拥有或排除某种特定的执行策略。如果某些任务依赖于其他的任务，那么会要求线程池足够大，从而确保它们依赖任务不会被放入等待队列中或被拒绝，而采用线程封闭机制的任务需要串行执行。</p></blockquote><h4 id="线程饥饿死锁"><a class="markdownIt-Anchor" href="#线程饥饿死锁"></a> 线程饥饿死锁</h4><p>在线程池中，如果任务依赖于其他任务，那么可能产生死锁。在单线程的<code>Executor</code>中，如果一个任务将另一个任务提交到同一个<code>Executor</code>，并且等待这个被提交任务的结果，那么通常会引发死锁。只要线程池中的任务需要无限期地等待一些必须由池中其他任务才能提供的资源或条件，就会发生线程饥饿死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在单线程Executor中任务发生死锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDeadlock</span> </span>&#123;</span><br><span class="line">  ExecutorService exec = Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderPageTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          Future&lt;String&gt; header = exec.submit(<span class="keyword">new</span> LoadFileTask(<span class="string">"header.html"</span>));</span><br><span class="line">          Future&lt;String&gt; footer = exec.submit(<span class="keyword">new</span> LoadFileTask(<span class="string">"footer.html"</span>));</span><br><span class="line">          String page = renderBody();</span><br><span class="line">          <span class="comment">//将发生死锁--由于任务在等待子任务的结果</span></span><br><span class="line">          <span class="keyword">return</span> header.get() + page + footer.get();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>每当提交了一个有依赖性的<code>Executor</code>任务时，要清楚地知道可能会出现线程饥饿死锁，因此需要在代码或配置<code>Executor</code>的配置文件中记录线程池的大小限制或配置限制。</p></blockquote><a id="more"></a><h4 id="运行时间较长的任务"><a class="markdownIt-Anchor" href="#运行时间较长的任务"></a> 运行时间较长的任务</h4><p>如果任务阻塞的时间过长，那么即使不出现死锁，线程池的响应性也会变得糟糕。为缓解这种影响，可以限定任务等待资源的时间，而不要无限制地等待。</p><h3 id="设置线程池的大小"><a class="markdownIt-Anchor" href="#设置线程池的大小"></a> 设置线程池的大小</h3><p>要想正确地设置线程池的大小，必须分析计算环境、资源预算和任务的特性。当任务需要某种通过资源池来管理的资源时，例如数据库连接，那么线程池和资源池的大小将会互相影响。</p><h3 id="配置threadpoolexecutor"><a class="markdownIt-Anchor" href="#配置threadpoolexecutor"></a> 配置ThreadPoolExecutor</h3><p>如果默认的执行策略不能满足需求，那么可以通过<code>ThreadPoolExecutor</code>的构造函数来实例化一个对象，并根据自己的需求来定制，并且可以参考<code>Executors</code>的源代码来了解默认配置下的执行策略，然后再以这些执行策略为基础进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadPoolExecutor的通用构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><h4 id="线程的创建与销毁"><a class="markdownIt-Anchor" href="#线程的创建与销毁"></a> 线程的创建与销毁</h4><p><strong>线程池的基本大小(<code>Core Pool Size</code>)、最大大小(<code>Maximum Pool Size</code>)以及存活时间等因素共同负责线程的创建与销毁。基本大小也就是线程池的目标大小，即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。线程池的最大大小表示可同时活动的线程数量的上限。如果某个线程的空闲时间超过了存活时间，那么将被标记为可回收的，并且当线程池的当前大小超过了基本大小时，这个线程将被终止。</strong></p><p>通过调节线程池的基本大小和存活时间，可以帮助线程池回收空闲线程占有的资源，从而使得这些资源可以用于执行其他工作。</p><p><code>newFixedThreadPool</code>工厂方法将线程池的基本大小和最大大小设置为参数中指定的值，而且创建的线程池不会超时。<code>newCachedThreadPool</code>工厂方法将线程池的最大大小设置为<code>Inter.MAX_VALUE</code>，从而将基本大小设置为零，并将超时设置为1分钟，这种方法创建出来的线程池可以被无限扩展，并且当需求降低时会自动收缩。</p><h4 id="管理队列任务"><a class="markdownIt-Anchor" href="#管理队列任务"></a> 管理队列任务</h4><p>在有限的线程池中会限制可并发执行的任务数量。如果新请求的到达速率超过了线程池的处理速率，那么新到来的请求将累积起来。在线程池中，这些请求会在一个由<code>Executor</code>管理的<code>Runnable</code>队列中等待，而不会像线程那样去竞争CPU资源。通过一个<code>Runnable</code>和一个链表节点来表现一个等待中的任务，当然比使用线程来表示的开销低很多，但如果客户提交给服务器请求的速率超过了处理器的处理速率，那么仍可能会耗尽资源。</p><p><code>ThreadPoolExecutor</code>允许提供一个<code>BlockingQueue</code>来保存等待执行的任务。基本的任务排队方法有3种：无界队列、有界队列和同步移交(<code>Synchronous Handoff</code>)。队列的选择与其他的配置参数有关，例如线程池的大小等。</p><p><code>newFixedThreadPool</code>和<code>newSingleThreadPool</code>在默认的情况下将使用一个无界的<code>LinkedBlockingQueue</code>。如果所有工作线程都处于忙碌状态，那么任务将在队列中等候。如果任务持续快速地到达，并且超过了线程池处理它们的速度，那么队列将无限制地增加。</p><p>一种更稳妥的资源管理策略是使用有界队列，例如<code>ArrayBlockingQueue</code>、有界的<code>LinkedBlockingQueue</code>。有界队列有助于避免资源耗尽的情况发生。在使用有界的工作队列时，队列的大小与线程池的大小必须一起调节。如果线程池较小而队列较大，那么有助于减少内存使用量，降低CPU的使用率，同时还可以减少上下文切换，但付出的代价是可能会限制吞吐量。</p><p>对于非常大的或者无界的线程池，可以通过使用<code>SynchronousQueue</code>来避免任务排队，以及直接将任务从生产者移交给工作者线程。<code>SynchronousQueue</code>不是一个真正的队列，而是一种在线程之间进行移交的机制。要将一个元素放入<code>SynchronousQueue</code>中，必须有另一个线程正在等待接受这个元素。如果没有线程正在等待，并且线程池的当前大小小于最大值，那么<code>ThreadPoolExecutor</code>将创建一个新的线程，否则根据饱和策略，这个任务将被拒绝。使用直接移交将更高效，因为任务会直接移交给执行它的线程，而不是被首先放在队列中，然后由工作线程从队列中提取该任务。只有当线程池是无界的或者可以拒绝任务时，<code>SynchronousQueue</code>才有实际价值。在<code>newCahcedThreadPool</code>工厂方法中就使用了<code>SynchronousQueue</code>。</p><p>当使用像<code>LinkedBlockingQueue</code>或<code>ArrayBlockingQueue</code>这样的<code>FIFO</code>队列时，任务的执行顺序与它们的到达顺序相同。如果想进一步控制任务执行顺序，还可以使用<code>PriorityBlockingQueue</code>，这个队列将根据优先级来安排任务。任务的优先级是通过自然顺序或<code>Comparator</code>(如果任务实现了<code>Comparable)</code>来定义。</p><blockquote><p>对于<code>Executor</code>，<code>newCachedThreadPool</code>工厂方法是一种很好的默认选择，它能提供比固定大小的线程池更好的排队性能。当需要限制当前任务的数量以满足资源管理需求时，那么可以选择固定大小的线程池，如果不进行限制，那么很容易发生过载问题。</p></blockquote><p>只有当任务相互独立时，为线程池或工作队列设置界限才是合理的。如果任务之间存在依赖性，那么有界的线程池或队列就可能导致线程“饥饿”死锁问题。此时应该使用无界的线程池，例如<code>newCachedThreadPool</code>。</p><h4 id="饱和策略"><a class="markdownIt-Anchor" href="#饱和策略"></a> 饱和策略</h4><p>当有界队列被填满后，饱和策略开始发挥作用。<code>ThreadPoolExecutor</code>的饱和策略可以通过调用<code>setRejectedExecutionHandler</code>来修改。(如果某个任务被提交到一个已被关闭的<code>Executor</code>时，也会用到饱和策略)。JDK提供了几种不同的<code>RejectedExecutionHandler</code>实现，每种实现都包含不同的饱和策略：<code>AbortPolicy</code>，<code>CallerRunsPolicy</code>，<code>DiscardPolicy</code>和<code>DiscardOldestPolicy</code>。</p><p>“中止(<code>Abort</code>)”策略是默认的饱和策略，该策略将抛出未检查的<code>RejectedExecutionException</code>。调用者可以捕获这个异常，然后根据需求编写自己的处理代码。当新提交的任务无法保存到队列中等待执行时，“抛弃(<code>Discard</code>)”策略会悄悄抛弃该任务。“抛弃最旧的(<code>Discard-Oldest</code>)”策略则会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。(如果工作队列是一个优先队列，那么“抛弃最旧的”策略将导致抛弃优先级最高的任务，因此最好不要将“抛弃最旧的”饱和策略和优先级队列放在一起使用。)</p><p>“调用者运行(<code>Caller-Runs</code>)”策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。它不会在线程池的某个线程中执行新提交的任务，而是在一个调用了<code>execute</code>的线程中执行该任务。</p><p>当创建<code>Eexcutor</code>时，可以选择饱和策略或者对执行策略进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor</span><br><span class="line">   = <span class="keyword">new</span> ThreadPoolExecutor(N_THREADS, N_THREADS,</span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(CAPACITY));</span><br><span class="line">executor.setRejectedExceptionHandler(</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure><h4 id="线程工厂"><a class="markdownIt-Anchor" href="#线程工厂"></a> 线程工厂</h4><p>每当线程池需要创建一个线程时，都是通过线程工厂方法来完成的。默认的线程工厂方法将创建一个新的、非守护的线程，并且不包含特殊的配置信息。通过指定一个线程工厂方法，可以定制线程池的配置信息。在<code>ThreadFactory</code>中之定义了一个方法<code>newThread</code>，每当线程池需要创建一个新线程时都会调用这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的线程工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String poolName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThreadFactory</span><span class="params">(String poolName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.poolName = poolName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyThread(runnable, poolName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定制Thread基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> staic <span class="keyword">final</span> String DEFAULT_NAME = <span class="string">"MyThread"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger created = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(r, DEFAULT_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Runnable runnable, String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(runnable, name + <span class="string">"-"</span> + created.incrementAndGet());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在调用构造函数后再定制threadpoolexecutor"><a class="markdownIt-Anchor" href="#在调用构造函数后再定制threadpoolexecutor"></a> 在调用构造函数后再定制ThreadPoolExecutor</h4><p>在调用完<code>ThreadPoolExecutor</code>的构造函数后，仍然可以通过设置函数(<code>Setter</code>)来修改大多数传递给它的构造函数的参数。如果<code>Executor</code>是通过<code>Executors</code>中的某个(<code>newSingleThreadExecutor</code>除外)工厂方法创建的，那么可以将结果的类型转换为<code>ThreadPoolExecutor</code>以访问设置器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对通过标准工厂方法创建的Executor进行修改</span></span><br><span class="line">ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"><span class="keyword">if</span>(exec <span class="keyword">instanceof</span> ThreadPoolExecutor) &#123;</span><br><span class="line">    ((ThreadPoolExecutor) exec).setCorePoolSize(<span class="number">10</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Oops, bad assumption"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Executors</code>中包含一个<code>unconfigurableExecutorService</code>工厂方法，该方法对一个现有的<code>ExecutorService</code>进行包装，使其只暴露出<code>EexcutorService</code>的方法，因此不能对它进行配置。<code>newSingleThreadExecutor</code>返回按这种方式封装的<code>ExecutorService</code>，而不是最初的<code>ThreadPoolExecutor</code>。虽然单线程的<code>Executor</code>实际上被实现为一个只包含唯一线程的线程池，但它同样确保了不会并发地执行任务。如果在代码中增加单线程<code>Executor</code>的线程池大小，那么将破坏它的执行语义。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;在任务与执行策略之间的隐形耦合&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#在任务与执行策略之间的隐形耦合&quot;&gt;&lt;/a&gt; 在任务与执行策略之间的隐形耦合&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;在一些任务中，需要拥有或排除某种特定的执行策略。如果某些任务依赖于其他的任务，那么会要求线程池足够大，从而确保它们依赖任务不会被放入等待队列中或被拒绝，而采用线程封闭机制的任务需要串行执行。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id=&quot;线程饥饿死锁&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#线程饥饿死锁&quot;&gt;&lt;/a&gt; 线程饥饿死锁&lt;/h4&gt;&lt;p&gt;在线程池中，如果任务依赖于其他任务，那么可能产生死锁。在单线程的&lt;code&gt;Executor&lt;/code&gt;中，如果一个任务将另一个任务提交到同一个&lt;code&gt;Executor&lt;/code&gt;，并且等待这个被提交任务的结果，那么通常会引发死锁。只要线程池中的任务需要无限期地等待一些必须由池中其他任务才能提供的资源或条件，就会发生线程饥饿死锁。&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//在单线程Executor中任务发生死锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadDeadlock&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ExecutorService exec = Executors.newSingleThreadExecutor();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RenderPageTask&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Callable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          Future&amp;lt;String&amp;gt; header = exec.submit(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LoadFileTask(&lt;span class=&quot;string&quot;&gt;&quot;header.html&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          Future&amp;lt;String&amp;gt; footer = exec.submit(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; LoadFileTask(&lt;span class=&quot;string&quot;&gt;&quot;footer.html&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          String page = renderBody();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;comment&quot;&gt;//将发生死锁--由于任务在等待子任务的结果&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; header.get() + page + footer.get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;每当提交了一个有依赖性的&lt;code&gt;Executor&lt;/code&gt;任务时，要清楚地知道可能会出现线程饥饿死锁，因此需要在代码或配置&lt;code&gt;Executor&lt;/code&gt;的配置文件中记录线程池的大小限制或配置限制。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Java Concurrency In Practice" scheme="https://maoyunfei.github.io/tags/Java-Concurrency-In-Practice/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程实战———取消与关闭</title>
    <link href="https://maoyunfei.github.io/java/40578055/"/>
    <id>https://maoyunfei.github.io/java/40578055/</id>
    <published>2018-12-18T16:00:00.000Z</published>
    <updated>2018-12-19T09:58:03.558Z</updated>
    
    <content type="html"><![CDATA[<p>要使任务和线程能安全、快速、可靠地停止下来，并不是一件容易的事。Java没有提供任何机制来安全地终止线程。但它提供了中断(<code>Interruption</code>)，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。</p><h3 id="任务取消"><a class="markdownIt-Anchor" href="#任务取消"></a> 任务取消</h3><p>如果外部代码能在某个操作正常完成之前将其置入“完成”状态，那么这个操作就称为可取消的。在Java中没有一种安全的抢占式方法来停止线程，因此也就没有安全的抢占方式来停止任务。只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。</p><p>其中一种协作机制能设置某个“已请求取消”标志，而任务将定期地查看该标志。如果设置了这个标记，那么任务将提前结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用volatile类型的域来保存取消状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;BigInteger&gt; primes = <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigInteger p = BigInteger.ONE;</span><br><span class="line">    <span class="keyword">while</span> (!cancelled) &#123;</span><br><span class="line">      p = p.nextProbablePrime();</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        primes.add(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cancelled = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> List&lt;BigInteger&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(primes);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个仅允许一秒钟的素数生成器</span></span><br><span class="line"><span class="function">List&lt;BigInteger&gt; <span class="title">aSecondOfPrimes</span><span class="params">()</span> <span class="keyword">throws</span> InterruptionException </span>&#123;</span><br><span class="line">  PrimeGenrator generator = <span class="keyword">new</span> PrimeGenerator();</span><br><span class="line">  <span class="keyword">new</span> Thread(generator).start();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    generator.cancel();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> generator.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="中断"><a class="markdownIt-Anchor" href="#中断"></a> 中断</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread中的中断方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>Thread</code>中包含了中断线程以及查询线程中断状态的方法：<code>interrupt</code>方法能中断目标线程，而<code>isInterrupted</code>方法能返回目标线程的中断状态，静态的<code>interrupted</code>方法将清除当前线程的中断状态，并返回它之前的值，这也是清除中断状态的唯一方法。</p><blockquote><p>调用<code>interrupt</code>并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息。</p></blockquote><p>对中断操作的正确理解是：它并不会真正地中断一个正在运行的线程，而只是发出中断请求，然后由线程在下一个合适的时刻中断自己。(这些时刻也被称为取消点)</p><p>在使用静态的<code>interrupted</code>时应该小心，因为它会清除当前线程的中断状态。如果在调用<code>interrupted</code>时返回了<code>true</code>，那么除非你想屏蔽这个中断，否则必须对它进行处理–可以抛出<code>InterruptedException</code>，或者通过再次调用<code>interrupt</code>来恢复中断状态。</p><blockquote><p>通常中断是实现取消的最合理方式。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过中断来取消</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line"></span><br><span class="line">  PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = queue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      BigInteger p = BigInteger.ONE;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        queue.put(p = p.nextProbablePrime());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException consumed) &#123;</span><br><span class="line">      <span class="comment">/* 允许线程退出 */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interrupt();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中断策略"><a class="markdownIt-Anchor" href="#中断策略"></a> 中断策略</h4><p>任务代码不应该对其执行所在的线程的中断策略做出假设，执行取消操作的代码也不应该对线程的中断策略做出假设。线程应该只能由其所有者中断，所有者可以将线程的中断策略信息封装到某个合适的取消机制中。</p><blockquote><p>由于每个线程拥有各自的中断策略，因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。</p></blockquote><h4 id="响应中断"><a class="markdownIt-Anchor" href="#响应中断"></a> 响应中断</h4><p>当调用可中断的阻塞函数时，例如<code>Thread.sleep</code>或<code>BlockingQueue.put</code>等，有两种实用策略可用于处理<code>InterruptedException</code>：</p><ul><li>传递异常，从而使你的方法也成为可中断的阻塞方法。</li><li>恢复中断状态，从而使调用栈中的上层代码能够对其进行处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将InterruptedException传递给调用者</span></span><br><span class="line">BlockingQueue&lt;Task&gt; queue;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> queue.take();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不可取消的任务在退出前恢复中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span><span class="params">(BlockingQueue&lt;Task&gt; queue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> queue.take();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         interrupted = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通过future来实现取消"><a class="markdownIt-Anchor" href="#通过future来实现取消"></a> 通过Future来实现取消</h4><p><code>Future</code>拥有一个<code>cancel</code>方法，该方法带有一个<code>boolean</code>类型的参数<code>mayInterruptIfRunning</code>，表示取消操作是否成功。(这只是表示任务是否能够接收中断，而不是表示任务是否能够检测并处理中断。) 如果<code>mayInterruptIfRunning</code>为<code>true</code>并且任务当前正在某个线程中运行，那么这个线程能被中断。如果这个参数为<code>false</code>，那么意味着“若任务还没有启动，就不要运行它”，这种方式应该用于那些不处理中断的任务中。</p><p>如果任务在标准的<code>Executor</code>中运行，并通过它们的<code>Future</code>来取消任务，那么可以设置<code>mayInterruptIfRunning</code>。当尝试取消某个任务时，不宜直接中断线程池，因为你并不知道当中断请求到达时正在运行什么任务–只能通过任务的<code>Future</code>来实现取消。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Future来取消任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  Future&lt;?&gt; task = taskExec.submit(r);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    task.get(timeout, unit);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">    <span class="comment">//接下来任务将被取消</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">//如果在任务中抛出了异常，那么重新抛出该异常</span></span><br><span class="line">    <span class="keyword">throw</span> launderThrowable(e.getCause);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//如果任务已经结束，那么执行取消操作也不会带来任何影响</span></span><br><span class="line">    task.cancel(<span class="keyword">true</span>);   <span class="comment">//如果任务正在运行，那么将被中断</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>Future.get</code>抛出<code>InterruptedException</code>或<code>TimeoutException</code>时，如果你知道不再需要结果，那么就可以调用<code>Future.cancel</code>来取消任务。</p><h3 id="停止基于线程的服务"><a class="markdownIt-Anchor" href="#停止基于线程的服务"></a> 停止基于线程的服务</h3><p>正确的封装原则是：除非拥有某个线程，否则不能对该线程进行操控。在线程<code>API</code>中，并没有对线程所有权给出正式的定义：线程由<code>Thread</code>对象表示，并且像其他对象一样可以被自由共享。然而，线程有一个相应的所有者，即创建该线程的类。因此线程池是其工作者线程的所有者，如果要中断这些线程，那么应该使用线程池。<br>与其他封装对象一样，线程的所有权是不可传递的：应用程序可以拥有服务，服务也可以拥有工作者线程，但应用程序并不能拥有工作者线程，因此应用程序不能直接停止工作者线程。相反，服务应该提供生命周期方法来关闭它自己以及它所拥有的线程。这样，当应用程序关闭该服务时，服务就可以关闭所有的线程了。</p><blockquote><p>对于持有线程的服务，只要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法。</p></blockquote><h4 id="关闭executorservice"><a class="markdownIt-Anchor" href="#关闭executorservice"></a> 关闭ExecutorService</h4><p><code>ExecutorService</code>提供了两种关闭方法：使用<code>shutdown</code>正常关闭，以及使用<code>shutdownNow</code>强行关闭。在进行强行关闭时，<code>shutdownNow</code>首先关闭当前正在执行的任务，然后返回所有尚未启动的任务清单。</p><h4 id="shutdownnow的局限性"><a class="markdownIt-Anchor" href="#shutdownnow的局限性"></a> shutdownNow的局限性</h4><p>当通过<code>shutdownNow</code>来强行关闭<code>ExecutorService</code>时，它会尝试取消正在执行的任务，并返回所有已提交但尚未开始的任务。然而，我们无法通过常规方法来找出哪些任务已经开始但尚未结束。</p><h3 id="jvm关闭"><a class="markdownIt-Anchor" href="#jvm关闭"></a> JVM关闭</h3><p><code>JVM</code>既可以正常关闭，也可以强行关闭。正常关闭的触发方式有多种，包括：当最后一个非守护线程结束时，或者当调用了<code>System.exit</code>时，或者通过其他特定于平台的方法关闭时。虽然可以通过这些标准方法来正常关闭<code>JVM</code>，但也可以通过调用<code>Runtime.halt</code>或者在操作系统中杀死<code>JVM</code>进程来强行关闭<code>JVM</code>。</p><h4 id="关闭钩子"><a class="markdownIt-Anchor" href="#关闭钩子"></a> 关闭钩子</h4><p>关闭钩子是指通过<code>Runtime.addShutdownHook</code>注册的但尚未开始的线程。在正常关闭中，<code>JVM</code>首先调用所有已注册的关闭钩子。<code>JVM</code>并不能保证关闭钩子的调用顺序。在关闭应用程序线程时，如果有线程仍然在运行，那么这些线程接下来将与关闭进程并发执行。<code>JVM</code>并不会停止或中断任何在关闭时仍然运行的应用程序线程。当<code>JVM</code>最终结束时，这些线程将被强行结束。如果关闭钩子或终结器没有执行完成，那么正常关闭进程挂起并且<code>JVM</code>必须强行关闭。当被强行关闭时，只是关闭<code>JVM</code>，而不会运行关闭钩子。</p><h4 id="守护线程"><a class="markdownIt-Anchor" href="#守护线程"></a> 守护线程</h4><p>线程分为两种：普通线程和守护线程。在<code>JVM</code>启动时创建的所有线程中，除了主线程以外，其他的线程都是守护线程。当创建一个新线程时，新线程将继承创建它的线程的守护状态，因此在默认情况下，主线程创建的所有线程都是普通线程。<br>普通线程与守护线程之间的差异仅在于当线程退出时发生的操作。当一个线程退出时，<code>JVM</code>会检查其他正在运行的线程，如果这些线程都是守护线程，那么<code>JVM</code>会正常退出操作。当<code>JVM</code>停止时，所有仍然存在的守护线程都将被抛弃–既不会执行<code>finally</code>代码块，也不会执行回卷栈，而<code>JVM</code>只是直接退出。<br>应尽可能少地使用守护线程，守护线程通常不能用来替代应用程序管理程序中各个服务的生命周期。</p><h4 id="终结器"><a class="markdownIt-Anchor" href="#终结器"></a> 终结器</h4><p>垃圾回收器对那些定义了<code>finalize</code>方法的对象会进行特殊处理：在回收器释放它们后，调用它们的<code>finalize</code>方法，从而保证一些持久化的资源释放。<br>在大多数情况下，通过使用<code>finally</code>代码块和显式的<code>close</code>方法，能够比使用终结器更好地管理资源。</p><blockquote><p>避免使用终结器。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;要使任务和线程能安全、快速、可靠地停止下来，并不是一件容易的事。Java没有提供任何机制来安全地终止线程。但它提供了中断(&lt;code&gt;Interruption&lt;/code&gt;)，这是一种协作机制，能够使一个线程终止另一个线程的当前工作。&lt;/p&gt;&lt;h3 id=&quot;任务取消&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#任务取消&quot;&gt;&lt;/a&gt; 任务取消&lt;/h3&gt;&lt;p&gt;如果外部代码能在某个操作正常完成之前将其置入“完成”状态，那么这个操作就称为可取消的。在Java中没有一种安全的抢占式方法来停止线程，因此也就没有安全的抢占方式来停止任务。只有一些协作式的机制，使请求取消的任务和代码都遵循一种协商好的协议。&lt;/p&gt;&lt;p&gt;其中一种协作机制能设置某个“已请求取消”标志，而任务将定期地查看该标志。如果设置了这个标记，那么任务将提前结束。&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//使用volatile类型的域来保存取消状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PrimeGenerator&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; List&amp;lt;BigInteger&amp;gt; primes = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;BigInteger&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; cancelled;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BigInteger p = BigInteger.ONE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (!cancelled) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      p = p.nextProbablePrime();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        primes.add(p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;cancel&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cancelled = &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;synchronized&lt;/span&gt; List&amp;lt;BigInteger&amp;gt; &lt;span class=&quot;title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;BigInteger&amp;gt;(primes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//一个仅允许一秒钟的素数生成器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;List&amp;lt;BigInteger&amp;gt; &lt;span class=&quot;title&quot;&gt;aSecondOfPrimes&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptionException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PrimeGenrator generator = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PrimeGenerator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(generator).start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SECONDS.sleep(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    generator.cancel();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; generator.get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Java Concurrency In Practice" scheme="https://maoyunfei.github.io/tags/Java-Concurrency-In-Practice/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程实战———任务执行</title>
    <link href="https://maoyunfei.github.io/java/ad6f24e8/"/>
    <id>https://maoyunfei.github.io/java/ad6f24e8/</id>
    <published>2018-12-11T16:00:00.000Z</published>
    <updated>2018-12-12T08:38:25.180Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在线程中执行任务"><a class="markdownIt-Anchor" href="#在线程中执行任务"></a> 在线程中执行任务</h3><h4 id="串行地执行任务"><a class="markdownIt-Anchor" href="#串行地执行任务"></a> 串行地执行任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//串行的Web服务器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleThreadWebServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      Socket connection = socket.accept();</span><br><span class="line">      handleRequest(connection);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="显式地为任务创建线程"><a class="markdownIt-Anchor" href="#显式地为任务创建线程"></a> 显式地为任务创建线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在Web服务器中为每个请求启动一个新的线程(不要这样做)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskWebServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line">      Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          handleRequest(connection);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>任务处理过程从主线程中分离出来，使得主循环能够更快地重新等待下一个到来的连接。这使得程序在完成前面的请求之前可以接受新的请求，从而提高响应性。</li><li>任务可以并行处理，从而能够同时服务多个请求。</li><li>任务处理代码必须是线程安全的，因为当有多个任务时会并发地调用这段代码。</li></ul><a id="more"></a><h4 id="无限制创建线程的不足"><a class="markdownIt-Anchor" href="#无限制创建线程的不足"></a> 无限制创建线程的不足</h4><ul><li><strong>线程生命周期的开销非常高。</strong> 线程的创建与销毁都是有代价的，需要JVM和操作系统提供一些辅助操作。</li><li><strong>资源消耗。</strong> 活跃的线程会消耗系统资源，尤其是内存。如果可运行的线程数量多于可用处理器数量，那么有些线程将闲置。大量闲置的线程会占用许多内存，给垃圾回收器带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销。<em>如果你已经拥有足够多的线程使所有CPU保持忙碌状态，那么再创建更多的线程反而会降低性能。</em></li><li><strong>稳定性。</strong> 在可创建线程的数量上存在一个限制。这个限制值受多个因素影响，包括JVM参数、<code>Thread</code>构造函数中请求的栈大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么很可能抛出<code>OutOfMemoryError</code>异常。</li></ul><h3 id="executor框架"><a class="markdownIt-Anchor" href="#executor框架"></a> Executor框架</h3><p>线程池简化了线程的管理工作，并且<code>java.util.concurrent</code>提供了一种灵活的线程池实现作为<code>Executor</code>框架的一部分。<strong>在Java类库中，任务执行的主要抽象不是<code>Thread</code>，而是<code>Executor</code>。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Executor</code>基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。如果要在程序中实现一个生产者-消费者的设计，那么最简单的方式通常就是使用<code>Executor</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞队列和Executor实现生产者-消费者模式</span></span><br><span class="line"> <span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> LinkedBlockingQueue&lt;Object&gt; queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(LinkedBlockingQueue&lt;Object&gt; queue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.queue = queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object o = <span class="keyword">new</span> Object();</span><br><span class="line">queue.put(o);</span><br><span class="line">System.out.println(<span class="string">"Producer: "</span> + o);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"Producer is interrupted!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> LinkedBlockingQueue&lt;Object&gt; queue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(LinkedBlockingQueue&lt;Object&gt; queue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.queue = queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object o = queue.take();</span><br><span class="line">System.out.println(<span class="string">"Consumer: "</span> + o);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"Consumer is interrupted!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//阻塞队列</span></span><br><span class="line">LinkedBlockingQueue&lt;Object&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Object&gt;(<span class="number">10</span>);</span><br><span class="line">ExecutorService es = Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">es.execute(<span class="keyword">new</span> Producer(queue));</span><br><span class="line">es.execute(<span class="keyword">new</span> Consumer(queue));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例基于executor的web服务器"><a class="markdownIt-Anchor" href="#示例基于executor的web服务器"></a> 示例：基于Executor的Web服务器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutionWebServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREADS = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> flnal Executor exec = Executors.newFixedThreadPool(NTHREADS);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> throw IOException </span>&#123;</span><br><span class="line">    ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line">      Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          handleRequest(connection);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      exec.execute(task);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h4><p>线程池是指管理一组同构工作线程的资源池。通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。另一个额外的好处是，当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙绿状态，同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。</p><p>类库提供了一个灵活的线程池以及一些有用的默认配置。可以通过调用<code>Executors</code>中的静态工厂方法来创建线程池：</p><ul><li><strong>newFixedThreadPool。</strong> <code>newFixedThreadPool</code>将创建一个固定长度的线程池，每当提交一个任务时就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化。</li><li><strong>newCachedThreadPool。</strong> <code>newCachedThreadPool</code>将创建一个可缓存的线程池，如果线程池的当前规模超过了处理需求时，那么将回收空闲的线程，而当需求增加时，则可以添加新的线程，线程池的规模不存在任何限制。</li><li><strong>newSingleThreadExecutor。</strong> <code>newSingleThreadExecutor</code>是一个单线程的<code>Executor</code>，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建另一个线程来代替。<code>newSingleThreadExecutor</code>能确保依照任务在队列中的顺序来串行执行。</li><li><strong>newScheduledThreadPool。</strong> <code>newScheduledThreadPool</code>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务。</li></ul><p><code>newFixedThreadPool</code>和<code>newCachedThreadPool</code>这两个工厂方法返回通用的<code>ThreadPoolExecutor</code>实例，这些实例可以直接用来构造专门用途的<code>executor</code>。</p><h4 id="executor的生命周期"><a class="markdownIt-Anchor" href="#executor的生命周期"></a> Executor的生命周期</h4><p>由于<code>Executor</code>以异步方式来执行任务，因此在任何时刻，之前提交的任务的状态不是立即可见的。有些任务可能已经完成，有些可能正在运行，而其他的任务可能在队列中等待执行。<code>Executor</code>是可关闭的(无论采用平缓的方式还是粗暴的方式)，并将在关闭操作中受影响的任务的状态反馈给应用程序。</p><p>为了解决执行服务的生命周期问题，<code>ExecutorService</code>接口扩展了<code>Executor</code>，添加了一些用于生命周期管理的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExecutorService中的生命周期管理方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ExecutorService</code>的生命周期有3种状态：运行、关闭和已终止。<code>ExecutorService</code>在初始创建时处于运行状态。<code>shutdown</code>方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成–包括那些还未开始执行的任务。<code>shutdownNow</code>方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。</p><p>在<code>ExecutorService</code>关闭后提交的任务将由“拒绝执行处理器(<code>Rejected Execution Handler</code>)”来处理，它会抛弃任务，或者使得<code>execute</code>方法抛出一个未检查的<code>RejectedExecutionException</code>。等所有任务都完成后，<code>ExecutorService</code>将转入终止状态。可以调用<code>awaitTermination</code>来等待<code>ExecutorService</code>到达终止状态，或者通过调用<code>isTerminated</code>来轮询<code>ExecutorService</code>是否已经终止。通常在调用<code>awaitTermination</code>之后会立即调用<code>shutdown</code>，从而产生同步地关闭<code>ExecutorService</code>的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//支持关闭操作的Web服务器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleWebServer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ServerSocket socket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">    <span class="keyword">while</span> (!exec.isShutdown()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              handleRequest(connection);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!exec.isShutdown()) &#123;</span><br><span class="line">          log(<span class="string">"task submission rejected"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    exec.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Socket connection)</span> </span>&#123;</span><br><span class="line">    Request req = readRequest(connection);</span><br><span class="line">    <span class="keyword">if</span> (isShutdownRequest(req)) &#123;</span><br><span class="line">      stop();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      dispatchRequest(req);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="延迟任务与周期任务"><a class="markdownIt-Anchor" href="#延迟任务与周期任务"></a> 延迟任务与周期任务</h4><p><code>Timer</code>类负责管理延迟任务以及周期任务。然而，<code>Timer</code>存在一些缺陷。<code>Timer</code>在执行所有定时任务时只会创建一个线程。如果某个任务的执行时间过长，那么将破坏其他<code>TimerTask</code>的定时准确性。<code>Timer</code>的另一个问题是，如果<code>TimerTask</code>抛出了一个未检查的异常，那么<code>Timer</code>将表现出糟糕的行为。<code>Timer</code>线程并不捕获异常，因此当<code>TimerTask</code>抛出未检查的异常时将终止定时线程，这种情况下，<code>Timer</code>也不会恢复线程的执行，而是会错误地认为整个<code>Timer</code>都被取消了。因此，已经被调度但尚未执行的<code>TimerTask</code>将不会再执行，新的任务也不能被调度(这个问题称之为“线程泄露”)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的Timer行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfTime</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">    timer.schedule(<span class="keyword">new</span> ThrowTask(), <span class="number">1</span>);</span><br><span class="line">    SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    timer.schedule(<span class="keyword">new</span> ThrowTask(), <span class="number">1</span>);</span><br><span class="line">    SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行一秒结束，并抛出一个异常消息“Timer already cancelled”</span></span><br></pre></td></tr></table></figure><p><code>ScheduledThreadPoolExecutor</code>能正确处理这些表现出错误行为的任务。在Java 5.0之后，很少使用<code>Timer</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建大小为5的线程池</span></span><br><span class="line">    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      Task worker = <span class="keyword">new</span> Task(<span class="string">"task-"</span>\ + i);</span><br><span class="line">      <span class="comment">// 只执行一次</span></span><br><span class="line">      <span class="comment">// scheduledThreadPool.schedule(worker, 5, TimeUnit.SECONDS);</span></span><br><span class="line">      <span class="comment">// 周期性执行，每5秒执行一次</span></span><br><span class="line">      scheduledThreadPool.scheduleAtFixedRate(worker, <span class="number">0</span>, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    System.out.println(<span class="string">"Shutting down executor..."</span>);</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    scheduledThreadPool.shutdown();</span><br><span class="line">    <span class="keyword">boolean</span> isDone;</span><br><span class="line">    <span class="comment">// 等待线程池终止</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      isDone = scheduledThreadPool.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">      System.out.println(<span class="string">"awaitTermination..."</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!isDone);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"Finished all threads"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"name = "</span> + name + <span class="string">", startTime = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"name = "</span> + name + <span class="string">", endTime = "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要构建自己的调度服务，那么可以利用<code>DelayQueue</code>，它实现了<code>BlockingQueue</code>，并为<code>ScheduledThreadPoolExecutor</code>提供调度功能。<code>DelayQueue</code>管理着一组<code>Delayed</code>对象。每个<code>Delayed</code>对象都有一个相应的延迟时间：在<code>DelayQueue</code>中，只有某个元素逾期后，才能从<code>DelayQueue</code>中执行<code>take</code>操作。从<code>DelayQueue</code>中返回的对象将根据它们的延迟时间进行排序。</p><h3 id="找出可利用的并行性"><a class="markdownIt-Anchor" href="#找出可利用的并行性"></a> 找出可利用的并行性</h3><h4 id="携带结果的任务callable与future"><a class="markdownIt-Anchor" href="#携带结果的任务callable与future"></a> 携带结果的任务Callable与Future</h4><p><code>Executor</code>框架使用<code>Runnable</code>作为其基本的任务表示形式。<code>Runnable</code>是一种有很大局限的抽象，它不能返回一个值或抛出一个受检查的异常。<code>Callable</code>是一种更好的抽象，它认为调用处将返回一个值，并可能抛出一个异常。</p><p><code>Executor</code>执行的任务有4个生命周期阶段：创建、提交、开始和完成。在<code>Executor</code>框架中，已提交但尚未开始的任务可以取消，但对于那些已经开始执行的任务，只有当它们能响应中断时，才能取消。取消一个已经完成的任务不会有任何影响。</p><p><code>Future</code>表示一个任务的生命周期，并提供了相应的方法来判断是否已经完成或取消，以及获取任务的结果和取消任务等。<code>get</code>方法的行为取决于任务的状态(尚未开始、正在运行、已完成)。如果任务已经完成，那么<code>get</code>会立即返回或者抛出一个<code>Exception</code>，如果任务没有完成，那么<code>get</code>将阻塞并直到任务完成。如果任务抛出了异常，那么<code>get</code>将该异常封装为<code>ExecutionException</code>并重新抛出。如果任务被取消，那么<code>get</code>将抛出<code>CancellationException</code>。如果<code>get</code>抛出了<code>ExecutionException</code>，那么可以通过<code>getCause</code>来获得被封装的初始异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Callable与Future接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, CancellationException</span>;</span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="completionserviceexecutor与blockingqueue"><a class="markdownIt-Anchor" href="#completionserviceexecutor与blockingqueue"></a> CompletionService：Executor与BlockingQueue</h4><p>如果向<code>Executor</code>提交了一组计算任务，并且希望在计算完成后获得结果，那么可以保留与每个任务关联的<code>Future</code>，然后反复使用<code>get</code>方法，同时将参数<code>timeout</code>指定为0，从而通过轮训来判断任务是否完成。这种方法有些繁琐，还有种更好的方法：完成服务(<code>CompletionService</code>)。</p><p><code>CompletionService</code>将<code>Executor</code>和<code>BlockingQueue</code>的功能融合在一起。你可以将<code>Callable</code>任务提交给它来执行，然后使用类似于队列操作的<code>take</code>和<code>poll</code>等方法来获得已完成的结果，而这些结果会在完成时将被封装为<code>Future</code>。<code>ExecutorCompletionService</code>实现了<code>CompletionService</code>，并将计算部分委托给一个<code>Executor</code>。</p><p><img src="https://github.com/maoyunfei/static-sources/blob/master/completionservice.jpg?raw=true" alt="CompletionService"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletionServiceDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executor = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    CompletionService&lt;Integer&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;Integer&gt;(executor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> Integer seq = i + <span class="number">1</span>;</span><br><span class="line">      completionService.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Thread.sleep((<span class="keyword">long</span>)(Math.random() * <span class="number">1000</span>));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="comment">// take 方法等待下一个结果并返回 Future 对象。</span></span><br><span class="line">      <span class="comment">// poll 不等待，有结果就返回一个 Future 对象，否则返回 null。</span></span><br><span class="line">      Future&lt;Integer&gt; future = completionService.take();</span><br><span class="line">      System.out.print(future.get() + <span class="string">";"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    executor.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="number">2</span>;<span class="number">3</span>;<span class="number">4</span>;<span class="number">1</span>;<span class="number">5</span>;<span class="number">7</span>;<span class="number">6</span>;<span class="number">10</span>;<span class="number">8</span>;<span class="number">9</span>;</span><br></pre></td></tr></table></figure><h4 id="为任务设置时限"><a class="markdownIt-Anchor" href="#为任务设置时限"></a> 为任务设置时限</h4><p>在支持时间限制的<code>Future.get</code>中支持这种需求：当结果可用时，它将立即返回，如果在指定时限内没有计算出结果，那么将抛出<code>TimeoutException</code>。当这些任务超时后应该立即停止，从而避免为继续计算一个不再使用的结果而浪费计算资源。要实现这个功能，可以由任务本身来管理它的限定时间，并且在超时后中止执行或取消任务。此时可再次使用<code>Future</code>，如果一个限时的<code>get</code>方法抛出了<code>TimeoutException</code>，那么可以通过<code>Future</code>来取消任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在指定时间内获取广告信息</span></span><br><span class="line"><span class="function">Page <span class="title">renderPageWithAd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> endNanos = System.nanoTime() + TIME_BUDGET;</span><br><span class="line">  Future&lt;Ad&gt; f = exec.submit(<span class="keyword">new</span> FetchAdTask());</span><br><span class="line">  <span class="comment">//在等待广告的同时显示页面</span></span><br><span class="line">  Page page = renderPageBody();</span><br><span class="line">  Ad ad;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//只等待指定的时间长度</span></span><br><span class="line">    <span class="keyword">long</span> timeLeft = endNanos - System.nanoTime();</span><br><span class="line">    ad = f.get(timeLeft, NANOSECONDS);</span><br><span class="line">  &#125; cache (ExecutionException e) &#123;</span><br><span class="line">    ad = DEFAULT_AD;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">    ad = DEFAULT_AD;</span><br><span class="line">    f.cancel(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  page.setAd(ad);</span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;在线程中执行任务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#在线程中执行任务&quot;&gt;&lt;/a&gt; 在线程中执行任务&lt;/h3&gt;&lt;h4 id=&quot;串行地执行任务&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#串行地执行任务&quot;&gt;&lt;/a&gt; 串行地执行任务&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//串行的Web服务器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingleThreadWebServer&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ServerSocket socket = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ServerSocket(&lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Socket connection = socket.accept();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      handleRequest(connection);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h4 id=&quot;显式地为任务创建线程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#显式地为任务创建线程&quot;&gt;&lt;/a&gt; 显式地为任务创建线程&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在Web服务器中为每个请求启动一个新的线程(不要这样做)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadPerTaskWebServer&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ServerSocket socket = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ServerSocket(&lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Socket connection = socket.accept();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Runnable task = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          handleRequest(connection);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(task).start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;任务处理过程从主线程中分离出来，使得主循环能够更快地重新等待下一个到来的连接。这使得程序在完成前面的请求之前可以接受新的请求，从而提高响应性。&lt;/li&gt;&lt;li&gt;任务可以并行处理，从而能够同时服务多个请求。&lt;/li&gt;&lt;li&gt;任务处理代码必须是线程安全的，因为当有多个任务时会并发地调用这段代码。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Java Concurrency In Practice" scheme="https://maoyunfei.github.io/tags/Java-Concurrency-In-Practice/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程实战———基础构建模块</title>
    <link href="https://maoyunfei.github.io/java/11c24b6b/"/>
    <id>https://maoyunfei.github.io/java/11c24b6b/</id>
    <published>2018-12-08T16:00:00.000Z</published>
    <updated>2018-12-09T07:10:25.711Z</updated>
    
    <content type="html"><![CDATA[<p>Java平台类库包含了丰富的并发基础构建模块，例如线程安全的容器类以及各种用于协调多个相互协作的线程控制流的同步工具类(<code>Synchronizer</code>)。</p><h3 id="同步容器类"><a class="markdownIt-Anchor" href="#同步容器类"></a> 同步容器类</h3><p>同步容器类包括<code>Vector</code>和<code>HashTable</code>，还包括由<code>Collections.synchronizedXxx</code>等工厂方法创建的封装器类。同步容器类可以简单地理解为通过<code>synchronized</code>来实现同步的容器。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。</p><h4 id="同步容器类的问题"><a class="markdownIt-Anchor" href="#同步容器类的问题"></a> 同步容器类的问题</h4><p>同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。容器上常见的复合操作包括：迭代、跳转以及条件运算。在同步容器类中，这些复合操作在没有客户端加锁的情况下仍然是线程安全的，但当其他线程并发地修改容器时，它们可能会表现出意料之外的行为。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复合操作非线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">  list.remove(lastIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁实现线程安全</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Object <span class="title">getLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> list.get(lastIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">deleteLast</span><span class="params">(Vector list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">    <span class="keyword">int</span> lastIndex = list.size() - <span class="number">1</span>;</span><br><span class="line">    list.remove(lastIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代器与concurrentmodificationexception"><a class="markdownIt-Anchor" href="#迭代器与concurrentmodificationexception"></a> 迭代器与ConcurrentModificationException</h4><p>对容器类进行迭代的过程中，如果有其他线程并发地修改容器，那么即使是使用迭代器也无法避免在迭代期间对容器加锁。当容器在迭代过程中被修改时，就会抛出一个<code>ConcurrentModificationException</code>异常。</p><p>同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性。这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重减低。</p><h3 id="并发容器"><a class="markdownIt-Anchor" href="#并发容器"></a> 并发容器</h3><p>并发容器是针对多个线程并发访问设计的。并发容器提供的迭代器不会抛出<code>ConcurrentModificationException</code>，因此不需要在迭代过程中对容器加锁。<code>ConcurrentHashMap</code>用来替代同步且基于散列的<code>Map</code>，<code>CopyOnWriteArrayList</code>用于在遍历操作为主要操作的情况下代替同步的<code>List</code>。</p><h4 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> ConcurrentHashMap</h4><p><code>ConcurrentHashMap</code>在Java 7中使用分段锁，在Java 8中使用<code>CAS</code>来实现并发操作。</p><p><code>ConcurrentHashMap</code>返回的迭代器具有弱一致性，弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以在迭代器被构造后将修改反映给容器。</p><p>对于一些需要在整个<code>Map</code>上进行计算的方法，例如<code>size</code>和<code>isEmpty</code>，这些方法的语义被略微减弱了以反映容器的并发特性。由于<code>size</code>返回的结果在计算时可能已经过期了，它实际上只是一个估计值，因此允许<code>size</code>返回一个近似值而不是一个精确值。</p><p>在<code>ConcurrentHashMap</code>中没有实现对<code>Map</code>加锁以提供独占访问，在大多数情况下，用<code>ConcurrentHashMap</code>来代替同步<code>Map</code>能进一步提高代码的可伸缩性，只有当应用程序需要加锁<code>Map</code>以进行独占访问时，才应该放弃使用<code>ConcurrentHashMap</code>。</p><h4 id="copyonwritearraylist"><a class="markdownIt-Anchor" href="#copyonwritearraylist"></a> CopyOnWriteArrayList</h4><p><code>CopyOnWriteArrayList</code>用于替代同步<code>List</code>，在某些情况下它提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。</p><p>“写入时复制(<code>Copy-On-Write</code>)”容器的线程安全性在于，只要正确地发布一个事实不可变的对象，那么在访问该对象时就不再需要进一步的同步。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。</p><p>“写入时复制”容器的迭代器保留一个指向底层基础数组的引用，这个数组当前位于迭代器的起始位置，由于它不会被修改，因此在对其进行同步时只需确保数组内容的可见性。因此，多个线程可以同时对这个容器进行迭代，而不会彼此干扰或者与修改容器的线程相互干扰。“写入时复制”容器返回的迭代器不会抛出<code>ConcurrentModificationException</code>，并且返回的元素与迭代器创建时的元素完全一致，而不必考虑之后修改操作所带来的影响。</p><p>每当修改容器时都会复制底层数组，这需要一定的开销，特别是当容器的规模较大时。<strong>仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器</strong>。</p><h3 id="同步工具类"><a class="markdownIt-Anchor" href="#同步工具类"></a> 同步工具类</h3><p>同步工具类可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流。阻塞队列可以作为同步工具类，其他类型的同步工具类还包括信号量(<code>Semaphore</code>)、栅栏(<code>Barrier</code>)以及闭锁(<code>Latch</code>)。</p><p>所有的同步工具类都包含一些特定的结构化属性：它们封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态。</p><h4 id="闭锁"><a class="markdownIt-Anchor" href="#闭锁"></a> 闭锁</h4><p>闭锁是一种同步工具类，可以延迟线程的进度直到其到达终止状态。闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。</p><p><code>CountDownLatch</code>是一种灵活的闭锁实现，它可以使一个或多个线程等待一组事件发生。闭锁状态包含一个计数器，该计数器初始化为一个正数，表示需要等待的事件数量。<code>countDown</code>方法递减计数器，表示有一个事件已经发生了，而<code>await</code>方法等待计数器达到零，这表示所有需要等待的事件都已经发生。如果计数器的值非零，那么<code>await</code>会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在计时测试中使用CountDownLatch来启动和停止线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTasks</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">      Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            startGate.await();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              task.run();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              endGate.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      t.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    startGate.countDown();</span><br><span class="line">    endGate.await();</span><br><span class="line">    <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">    <span class="keyword">return</span> end - start;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="futuretask"><a class="markdownIt-Anchor" href="#futuretask"></a> FutureTask</h4><p><code>FutureTask</code>也可以用作闭锁。<code>FutureTask</code>表示的计算是通过Callable来实现的，相当于一种可生成结果的<code>Runnable</code>，并且可以处于以下3种状态：等待运行，正在运行和运行完成。“执行完成”表示计算的所有可能结束方式，包括正常结束、由于取消而结束和由于异常而结束等。</p><p><code>Future.get</code>的行为取决于任务的状态。如果任务已经完成，那么<code>get</code>会立即返回结果，否则<code>get</code>将阻塞直到任务进入完成状态，然后返回结果或者抛出异常。</p><p><code>FutureTask</code>在<code>Executor</code>框架中表示异步任务，此外还可以用来表示一些时间较长的计算，这些计算可以在使用计算结果之前启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用FutureTask来提前加载稍后需要的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Preloader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FutureTask&lt;ProductInfo&gt; future = <span class="keyword">new</span> FutureTask&lt;ProductInfo&gt;(</span><br><span class="line">      <span class="keyword">new</span> Callable&lt;ProductInfo&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> DataLoadException </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> loadProductInfo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(future);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    thread.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ProductInfo <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> DataLoadException, InterruptException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> future.get();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">      Throwable cause = e.getCause();</span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> DataLoadException)&#123;</span><br><span class="line">        <span class="keyword">throw</span> (DataLoadException) cause;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> launderThrowable(cause);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//强制将未检查的Throwable转换为RuntimeException</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RuntimeException <span class="title">launderThrowable</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">      <span class="keyword">return</span> (RuntimeException) t;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> (Error) t;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Not unchecked"</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h4><p><code>Semaphore</code>中管理着一组虚拟的许可(<code>permit</code>)，许可的初始数量可通过构造函数来指定。在执行操作时先要获取许可，并在使用以后释放许可。如果没有许可，那么<code>acquire</code>将阻塞直到有许可(或者直到被中断或者操作超时)。<code>release</code>方法将返回一个许可给信号量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Semaphore为容器设置边界</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedHashSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">    asm = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    asm.acquire();</span><br><span class="line">    <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      wasAdded = set.add(o);</span><br><span class="line">      <span class="keyword">return</span> wasAdded;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!wasAdded) &#123;</span><br><span class="line">        asm.release();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> wasRemoved = set.remove(o);</span><br><span class="line">    <span class="keyword">if</span> (wasRemoved) &#123;</span><br><span class="line">      asm.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wasRemoved;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栅栏"><a class="markdownIt-Anchor" href="#栅栏"></a> 栅栏</h4><p>栅栏类似于闭锁，它能阻塞一组线程直到某个事件发生。栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。</p><p><code>CyclicBarrier</code>可以使一定数量的参与方反复地在栅栏位置汇集，当线程到达栅栏位置时将调用<code>await</code>方法，这个方法将阻塞直到所有线程都到达栅栏位置。如果所有线程都到达栅栏位置，那么栅栏将打开，此时所有线程都被释放，而栅栏被重置以便下次使用。如果对<code>await</code>的调用超时，或者<code>await</code>阻塞的线程被中断，那么栅栏就被认为是打破了，所有阻塞的<code>await</code>调用都将终止并抛出<code>BrokenBarrierException</code>。如果成功地通过栅栏，那么<code>await</code>将为每个线程返回一个唯一的到达索引号。<code>CyclicBarrier</code>还可以使你将一个栅栏操作传递给构造函数，这是一个<code>Runnable</code>，当成功通过栅栏时执行它。</p><p><code>CyclicBarrier</code>有两个构造参数，分别是：</p><ul><li><code>CyclicBarrier(int parties)</code><br>创建一个新的<code>CyclicBarrier</code>，它将在给定数量的参与者(线程)处于等待状态时启动，但它不会在启动<code>barrier</code>时执行预定义的操作。</li><li><code>CyclicBarrier(int parties, Runnable barrierAction)</code><br>创建一个新的<code>CyclicBarrier</code>，它将在给定数量的参与者(线程)处于等待状态时启动，并在启动<code>barrier</code>时执行给定的屏障操作，该操作<strong>由最后一个进入<code>barrier</code>的线程执行</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运动会所有选手都就位后才开始</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Athlete</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Athlete</span><span class="params">(CyclicBarrier cyclicBarrier, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(name + <span class="string">"就位"</span>)；</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      cyclicBarrier.await();</span><br><span class="line">      Random random = <span class="keyword">new</span> Random();</span><br><span class="line">      <span class="keyword">double</span> time = random.nextDouble() + <span class="number">9</span>;</span><br><span class="line">      System.out.println(name + <span class="string">": "</span> + time);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Race</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">8</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Athlete&gt; athletes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    athleteList.add(<span class="keyword">new</span> Athlete(cyclicBarrier,<span class="string">"选手一"</span>));</span><br><span class="line">    athleteList.add(<span class="keyword">new</span> Athlete(cyclicBarrier,<span class="string">"选手二"</span>));</span><br><span class="line">    athleteList.add(<span class="keyword">new</span> Athlete(cyclicBarrier,<span class="string">"选手三"</span>));</span><br><span class="line">    athleteList.add(<span class="keyword">new</span> Athlete(cyclicBarrier,<span class="string">"选手四"</span>));</span><br><span class="line">    athleteList.add(<span class="keyword">new</span> Athlete(cyclicBarrier,<span class="string">"选手五"</span>));</span><br><span class="line">    athleteList.add(<span class="keyword">new</span> Athlete(cyclicBarrier,<span class="string">"选手六"</span>));</span><br><span class="line">    athleteList.add(<span class="keyword">new</span> Athlete(cyclicBarrier,<span class="string">"选手七"</span>));</span><br><span class="line">    athleteList.add(<span class="keyword">new</span> Athlete(cyclicBarrier,<span class="string">"选手八"</span>));</span><br><span class="line">    Executor executor = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (Athlete athlete : athleteList) &#123;</span><br><span class="line">      executor.execute(athlete);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CountDownLatch</code>是一次性使用的，如果需要可重用的<code>CountDownLatch</code>，考虑使用<code>CyclicBarrier</code>。</p><p>详细分析可参考<a href="https://juejin.im/entry/596a05fdf265da6c4f34f2f9" target="_blank" rel="noopener">Java并发之CyclicBarrier</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java平台类库包含了丰富的并发基础构建模块，例如线程安全的容器类以及各种用于协调多个相互协作的线程控制流的同步工具类(&lt;code&gt;Synchronizer&lt;/code&gt;)。&lt;/p&gt;&lt;h3 id=&quot;同步容器类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#同步容器类&quot;&gt;&lt;/a&gt; 同步容器类&lt;/h3&gt;&lt;p&gt;同步容器类包括&lt;code&gt;Vector&lt;/code&gt;和&lt;code&gt;HashTable&lt;/code&gt;，还包括由&lt;code&gt;Collections.synchronizedXxx&lt;/code&gt;等工厂方法创建的封装器类。同步容器类可以简单地理解为通过&lt;code&gt;synchronized&lt;/code&gt;来实现同步的容器。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。&lt;/p&gt;&lt;h4 id=&quot;同步容器类的问题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#同步容器类的问题&quot;&gt;&lt;/a&gt; 同步容器类的问题&lt;/h4&gt;&lt;p&gt;同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。容器上常见的复合操作包括：迭代、跳转以及条件运算。在同步容器类中，这些复合操作在没有客户端加锁的情况下仍然是线程安全的，但当其他线程并发地修改容器时，它们可能会表现出意料之外的行为。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Java Concurrency In Practice" scheme="https://maoyunfei.github.io/tags/Java-Concurrency-In-Practice/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程实战———ThreadLocal深度解析</title>
    <link href="https://maoyunfei.github.io/java/f669ed98/"/>
    <id>https://maoyunfei.github.io/java/f669ed98/</id>
    <published>2018-12-05T16:00:00.000Z</published>
    <updated>2018-12-19T09:53:24.215Z</updated>
    
    <content type="html"><![CDATA[<p><code>ThreadLocal</code>提供了线程的局部变量，每个线程都可以通过<code>set()</code>和<code>get()</code>来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，<strong>实现了线程的数据隔离</strong>。</p><h3 id="如何使用threadlocal"><a class="markdownIt-Anchor" href="#如何使用threadlocal"></a> 如何使用ThreadLocal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          threadLocal.set(i);</span><br><span class="line">          threadLocal.get();</span><br><span class="line">          threadLocal.remove();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先需要创建一个线程共享的<code>ThreadLocal</code>对象，该对象用于存储<code>Integer</code>类型的值，然后在每条线程中调用以下方法操作<code>ThreadLocal</code>:</p><ul><li><code>set(obj)</code>：向当前线程中存储数据</li><li><code>get()</code>：获取当前线程中的数据</li><li><code>remove()</code>：删除当前线程中的数据</li></ul><a id="more"></a><h3 id="threadlocal实现原理"><a class="markdownIt-Anchor" href="#threadlocal实现原理"></a> ThreadLocal实现原理</h3><p><img src="https://github.com/maoyunfei/static-sources/blob/master/threadlocal.jpg?raw=true" alt="ThreadLocal"></p><p><code>ThreadLocal</code>并不维护<code>ThreadLocalMap</code>，它只是相当于一个工具包，提供了操作该容器的方法，如<code>get</code>、<code>set</code>、<code>remove</code>等。而<code>ThreadLocal</code>内部类<code>ThreadLocalMap</code>才是存储数据的容器，并且该容器由<code>Thread</code>维护。</p><p>每一个<code>Thread</code>对象均含有一个<code>ThreadLocalMap</code>类型的成员变量<code>threadLocals</code>，它存储本线程中所有<code>ThreadLocal</code>对象及其对应的值。</p><p><code>ThreadLocalMap</code>由一个个<code>Entry</code>对象构成，<code>Entry</code>的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Entry</code>继承自<code>WeakReference&lt;ThrealLocal&lt;?&gt;&gt;</code>，一个<code>Entry</code>由<code>ThreadLocal</code>对象和<code>Object</code>构成。由此可见，<code>Entry</code>的<code>key</code>是<code>ThreadLocal</code>对象，并且是一个弱引用。当没指向<code>key</code>的强引用后，该<code>key</code>就会被垃圾收集器回收。</p><p><code>ThreadLocal</code>的<code>set</code>和<code>get</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行<code>set</code>方法时，<code>ThreadLocal</code>首先会获取当前线程对象，然后获取当前线程的<code>ThreadLocalMap</code>对象。再以当前<code>ThreadLocal</code>对象为<code>key</code>，将值存储进<code>ThreadLocalMap</code>对象中。</p><p><code>get</code>方法执行过程类似。<code>ThreadLocal</code>首先会获取当前线程对象，然后获取当前线程的<code>ThreadLocalMap</code>对象。再以当前<code>ThreadLocal</code>对象为<code>key</code>，获取对应的<code>value</code>。</p><p>由于每一条线程均含有各自<strong>私有的</strong><code>ThreadLocalMap</code>容器，这些容器相互独立互不影响，因此不会存在线程安全性问题，从而也无需使用同步机制来保证多条线程访问容器的互斥性。</p><h3 id="threadlocal的内存泄露问题"><a class="markdownIt-Anchor" href="#threadlocal的内存泄露问题"></a> ThreadLocal的内存泄露问题</h3><p><img src="https://github.com/maoyunfei/static-sources/blob/master/threadlocal_in-mem.jpg?raw=true" alt=""></p><p>在<code>ThreadLocalMap</code>中，只有<code>key</code>是弱引用，<code>value</code>仍然是一个强引用。当某一条线程中的<code>ThreadLocal</code>使用完毕，没有强引用指向它的时候，这个<code>key</code>指向的对象就会被垃圾收集器回收，从而这个<code>key</code>就变成了<code>null</code>；然而，此时<code>value</code>和<code>value</code>指向的对象之间仍然是强引用关系，只要这种关系不解除，<code>value</code>指向的对象永远不会被垃圾收集器回收，从而导致内存泄漏！</p><p>不过不用担心，<code>ThreadLocal</code>提供了这个问题的解决方案。</p><p>每次操作<code>set</code>、<code>get</code>、<code>remove</code>操作时，<code>ThreadLocal</code>都会将<code>key</code>为<code>null</code>的<code>Entry</code>删除，从而避免内存泄漏。</p><p>那么问题又来了，如果一个线程运行周期较长，而且将一个大对象放入<code>ThreadLoalMap</code>后便不再调用<code>set</code>、<code>get</code>、<code>remove</code>方法，此时该仍然可能会导致内存泄漏。</p><p>这个问题确实存在，没办法通过<code>ThreadLocal</code>解决，而是需要程序员在完成<code>ThreadLocal</code>的使用后要养成手动调用<code>remove</code>的习惯，从而避免内存泄漏。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;提供了线程的局部变量，每个线程都可以通过&lt;code&gt;set()&lt;/code&gt;和&lt;code&gt;get()&lt;/code&gt;来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，&lt;strong&gt;实现了线程的数据隔离&lt;/strong&gt;。&lt;/p&gt;&lt;h3 id=&quot;如何使用threadlocal&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#如何使用threadlocal&quot;&gt;&lt;/a&gt; 如何使用ThreadLocal&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Main&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          threadLocal.set(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          threadLocal.get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          threadLocal.remove();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;).start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;首先需要创建一个线程共享的&lt;code&gt;ThreadLocal&lt;/code&gt;对象，该对象用于存储&lt;code&gt;Integer&lt;/code&gt;类型的值，然后在每条线程中调用以下方法操作&lt;code&gt;ThreadLocal&lt;/code&gt;:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;set(obj)&lt;/code&gt;：向当前线程中存储数据&lt;/li&gt;&lt;li&gt;&lt;code&gt;get()&lt;/code&gt;：获取当前线程中的数据&lt;/li&gt;&lt;li&gt;&lt;code&gt;remove()&lt;/code&gt;：删除当前线程中的数据&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Java Concurrency In Practice" scheme="https://maoyunfei.github.io/tags/Java-Concurrency-In-Practice/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程实战———对象的共享</title>
    <link href="https://maoyunfei.github.io/java/27492a68/"/>
    <id>https://maoyunfei.github.io/java/27492a68/</id>
    <published>2018-12-03T16:00:00.000Z</published>
    <updated>2018-12-06T06:26:12.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="可见性"><a class="markdownIt-Anchor" href="#可见性"></a> 可见性</h3><p>为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p><h4 id="非原子的64位操作"><a class="markdownIt-Anchor" href="#非原子的64位操作"></a> 非原子的64位操作</h4><p>Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非<code>volatile</code>类型的<code>double</code>和<code>long</code>变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非<code>volatile</code>类型的<code>long</code>变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的<code>long</code>和<code>double</code>等类型的变量也是不安全的，除非用关键字<code>volatile</code>来声明它们，或者用锁保护起来。</p><a id="more"></a><h4 id="加锁与可见性"><a class="markdownIt-Anchor" href="#加锁与可见性"></a> 加锁与可见性</h4><blockquote><p>加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。</p></blockquote><h4 id="volatile变量"><a class="markdownIt-Anchor" href="#volatile变量"></a> volatile变量</h4><p>Java语言提供了一种稍弱的同步机制，即<code>volatile</code>变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为<code>volatile</code>类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。<code>volatile</code>变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取<code>volatile</code>类型的变量时总会返回最新写入的值。</p><blockquote><p>加锁机制既可以确保可见性又可以确保原子性，而<code>volatile</code>变量只能确保可见性。</p></blockquote><p>当且仅当满足以下所有条件时，才应该使用<code>volatile</code>变量：</p><ul><li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li><li>该变量不会与其他状态变量一起纳入不变性条件中，</li><li>在访问变量时不需要加锁。</li></ul><h3 id="线程封闭"><a class="markdownIt-Anchor" href="#线程封闭"></a> 线程封闭</h3><p>当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭，它是实现线程安全性的最简单方式之一。</p><h4 id="ad-hoc线程封闭"><a class="markdownIt-Anchor" href="#ad-hoc线程封闭"></a> Ad-hoc线程封闭</h4><p><code>Ad-hoc</code>线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。</p><p><code>Ad-hoc</code>线程封闭是非常脆弱的，因为没有任何一种语言特性，能将对象封闭到目标线程上。</p><h4 id="栈封闭"><a class="markdownIt-Anchor" href="#栈封闭"></a> 栈封闭</h4><p>栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中，它们位于执行线程的栈中，其他线程无法访问这个栈。栈封闭比<code>Ad-hoc</code>线程封闭更易于维护，也更加健壮。</p><p>在维持对象引用的栈封闭性时，程序员需要多做一些工作以确保被引用的对象不会逸出。</p><h4 id="threadlocal类"><a class="markdownIt-Anchor" href="#threadlocal类"></a> ThreadLocal类</h4><p>维持线程封闭性的一种更规范方法是使用<code>ThreadLocal</code>，这个类能使线程中的某个值与保存值的对象关联起来。<code>ThreadLocal</code>提供了<code>get</code>和<code>set</code>等访问接口或方法，这些方法为每个使用该变量线程都存有一份独立的副本，因此<code>get</code>总是返回由当前执行线程在调用<code>set</code>时设置的最新值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal</code>变量类似于全局变量，它能降低代码的可重用性，并在类之间引入隐含的耦合性，因此在使用时要格外小心。</p><h3 id="不变性"><a class="markdownIt-Anchor" href="#不变性"></a> 不变性</h3><p>满足同步需求的另一种方法是使用不可变对象。如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象。</p><blockquote><p>不可变对象一定是线程安全的。</p></blockquote><p>当满足以下条件时，对象才是不可变的：</p><ul><li>对象创建以后其状态就不能修改。</li><li>对象的所有域都是<code>final</code>类型。</li><li>对象是正确创建的(在对象的创建期间，<code>this</code>引用没有逸出)。</li></ul><h3 id="安全地共享对象"><a class="markdownIt-Anchor" href="#安全地共享对象"></a> 安全地共享对象</h3><p>在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：</p><blockquote><p><strong>线程封闭</strong>：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。<br><strong>只读共享</strong>：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。<br><strong>线程安全共享</strong>：线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。<br><strong>保护对象</strong>：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;可见性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#可见性&quot;&gt;&lt;/a&gt; 可见性&lt;/h3&gt;&lt;p&gt;为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。&lt;/p&gt;&lt;h4 id=&quot;非原子的64位操作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#非原子的64位操作&quot;&gt;&lt;/a&gt; 非原子的64位操作&lt;/h4&gt;&lt;p&gt;Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非&lt;code&gt;volatile&lt;/code&gt;类型的&lt;code&gt;double&lt;/code&gt;和&lt;code&gt;long&lt;/code&gt;变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取一个非&lt;code&gt;volatile&lt;/code&gt;类型的&lt;code&gt;long&lt;/code&gt;变量时，如果对该变量的读操作和写操作在不同的线程中执行，那么很可能会读取到某个值的高32位和另一个值的低32位。因此，即使不考虑失效数据问题，在多线程程序中使用共享且可变的&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;等类型的变量也是不安全的，除非用关键字&lt;code&gt;volatile&lt;/code&gt;来声明它们，或者用锁保护起来。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Java Concurrency In Practice" scheme="https://maoyunfei.github.io/tags/Java-Concurrency-In-Practice/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想———泛型</title>
    <link href="https://maoyunfei.github.io/java/a9885224/"/>
    <id>https://maoyunfei.github.io/java/a9885224/</id>
    <published>2018-12-01T16:00:00.000Z</published>
    <updated>2018-12-03T06:16:09.889Z</updated>
    
    <content type="html"><![CDATA[<p>泛型实现了<strong>参数化类型</strong>的概念。</p><p>根据泛型应用的不同，可分为：</p><ul><li><p>泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassParameter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">f</span><span class="params">(T arg)</span> </span>&#123; <span class="keyword">return</span> arg; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceParameter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">f</span><span class="params">(T arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodParameter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">f</span><span class="params">(T arg)</span> </span>&#123; <span class="keyword">return</span> arg; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h3 id="泛型的擦除"><a class="markdownIt-Anchor" href="#泛型的擦除"></a> 泛型的擦除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">    Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">    System.out.println(c1 == c2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>Java泛型是使用<strong>擦除</strong>来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此，<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>在运行时事实上是相同的类型。这两种形式都被擦除成它们的原生类型，即<code>List</code>。</p><p>在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文环境中使用的类型。</p><p>泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上界。</p><p>擦除的代价是显著的，泛型不能用于显示地引用运行时类型的操作之中，例如转型、<code>instanceof</code>操作和<code>new</code>表达式。</p><h3 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h3><p>在使用Java泛型时会出现的各类问题。</p><ol><li>任何基本类型都不能作为类型参数。</li></ol><p>解决办法是使用基本类型的包装器类及自动装箱机制。<code>ArrayList&lt;Integer&gt;</code></p><ol start="2"><li>实现参数化接口</li></ol><p>一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两种变体会成为相同的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt; </span>&#123;&#125;</span><br><span class="line"><span class="comment">//Hourly无法编译</span></span><br></pre></td></tr></table></figure><ol start="3"><li>转型和警告</li></ol><p>使用带有泛型类型参数的转型或instanceof不会有任何效果。</p><ol start="4"><li>重载</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无法编译</span></span><br></pre></td></tr></table></figure><p>由于擦除的原因，重载方法将产生相同的类型签名。</p><p>当被擦除的参数不能产生唯一的参数列表时，必须提供明显有区别的方法名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList2</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>基类劫持了接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Pet</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Pet arg)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">ComparablePet</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> compareTo&lt;ComparablePet arg&gt; &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">ComparablePet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//Error: Comparable不能被不同的参数Cat和Pet继承</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> compareTo&lt;Cat arg&gt; &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组与泛型"><a class="markdownIt-Anchor" href="#数组与泛型"></a> 数组与泛型</h3><p>不能实例化具有参数化类型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Peel&lt;Banana&gt;[] peels = <span class="keyword">new</span> Peel&lt;Banana&gt;[<span class="number">10</span>]; <span class="comment">//非法</span></span><br></pre></td></tr></table></figure><p>擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全。</p><p>但是，可以参数化数组本身的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassParameter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> T[] f(T[] arg) &#123; <span class="keyword">return</span> arg; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodParameter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> T[] f(T[] arg) &#123; <span class="keyword">return</span> arg; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterizedArrayType</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer[] ints = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    Double[] doubles = &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span> &#125;;</span><br><span class="line">    Integer[] ints2 = <span class="keyword">new</span> ClassParameter&lt;Integer&gt;().f(ints);</span><br><span class="line">    Double[] doubles2 = <span class="keyword">new</span> ClassParameter&lt;Double&gt;().f(doubles);</span><br><span class="line">    ints2 = MethodParameter.f(ints);</span><br><span class="line">    doubles2 = MethodParameter.f(doubles);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;泛型实现了&lt;strong&gt;参数化类型&lt;/strong&gt;的概念。&lt;/p&gt;&lt;p&gt;根据泛型应用的不同，可分为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;泛型类&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ClassParameter&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; T &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T arg)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arg; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;泛型接口&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InterfaceParameter&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;T &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T arg)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;泛型方法&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MethodParameter&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;T &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(T arg)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arg; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Thinking in Java" scheme="https://maoyunfei.github.io/tags/Thinking-in-Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想———动态代理</title>
    <link href="https://maoyunfei.github.io/java/aef2e083/"/>
    <id>https://maoyunfei.github.io/java/aef2e083/</id>
    <published>2018-11-25T16:00:00.000Z</published>
    <updated>2018-12-06T06:27:35.335Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是代理"><a class="markdownIt-Anchor" href="#什么是代理"></a> 什么是代理</h3><p>代理是基本的设计模式之一，给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。</p><p>通过使用代理，通常有两个优点：</p><ul><li>可以隐藏委托类的实现。</li><li>可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。</li></ul><a id="more"></a><h3 id="静态代理"><a class="markdownIt-Anchor" href="#静态代理"></a> 静态代理</h3><p>若代理类在程序运行前就已经存在，那么这种代理方式被称为<strong>静态代理</strong>，这种情况下的代理类通常都是我们在Java代码中定义的。通常情况下，静态代理中的代理类和委托类会实现同一接口或是派生自相同的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 委托类和代理类都实现Sell接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sell</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ad</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 委托类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vendor</span> <span class="title">inplements</span> <span class="title">Sell</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"In sell method"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ad method"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 代理类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="title">inplements</span> <span class="title">Sell</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Vendor vendor;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Agent</span><span class="params">(Vendor vendor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vendor = vendor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vendor.sell();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vendor.ad();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码可以看出，静态代理可以通过聚合来实现，让代理类持有一个委托类的引用即可。</p><p>静态代理的局限在于运行前必须编写好代理类。</p><h3 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h3><p>代理类在程序运行时创建的代理方式被称为<strong>动态代理</strong>。这种情况，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指令”动态生成的。</p><p>动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数。</p><p>现在假设我们需要，在执行委托类中的方法之前输出“<code>before</code>”，在执行完毕之后输出“<code>after</code>”。</p><p>静态代理的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticAgent</span> <span class="keyword">implements</span> <span class="title">Sell</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Vendor vendor;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">StaticAgent</span><span class="params">(Vendor vendor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.vendor = vendor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    vendor.sell();</span><br><span class="line">    System.out.println(<span class="string">"before"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    vendor.ad();</span><br><span class="line">    System.out.println(<span class="string">"before"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用动态代理实现"><a class="markdownIt-Anchor" href="#使用动态代理实现"></a> 使用动态代理实现</h4><ul><li><p><strong>InvocationHandler接口</strong></p><p>在使用动态代理是，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现<code>InvocationHandler</code>接口，这个接口的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 调用处理程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了这个接口的中介类叫做“调用处理类”，当我们调用代理类对象的方法时，这个调用会转送到<code>invoke</code>方法中，代理类对象作为<code>proxy</code>参数传入，参数<code>method</code>标识了我们具体调用的是代理类的哪个方法，<code>args</code>为这个方法的参数。这样一来，我们对代理类中的所有方法的调用都会变为对<code>invoke</code>的调用，这样我们可以在<code>invoke</code>方法中添加统一的处理逻辑。</p></li><li><p>中介类的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">//object为委托类对象</span></span><br><span class="line">  <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.obj = obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"before"</span>);</span><br><span class="line">    Object result = method.invoke(obj, args);</span><br><span class="line">    System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码可以看出，中介类持有一个委托类对象引用，在<code>invoke</code>方法中调用了委托类对象的相应方法。</p></li><li><p>动态生成代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建中介类实例</span></span><br><span class="line">    DynamicProxy inter = <span class="keyword">new</span> DynamicProxy(<span class="keyword">new</span> Vendor());</span><br><span class="line">    <span class="comment">//加上这句将会产生一个$Proxy0.class文件，这个文件即为动态生成的代理类文件</span></span><br><span class="line">    System.getProperties.put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">    <span class="comment">//获取代理类实例</span></span><br><span class="line">    Sell sell = (Sell)(Proxy.newProxyInstance(Sell.class.getClassLoader(), <span class="keyword">new</span> Class[] &#123;Sell.class&#125;, inter));</span><br><span class="line">    <span class="comment">//通过代理类对象调用代理类方法，实际上会转到invoke方法执行。</span></span><br><span class="line">    sell.sell();</span><br><span class="line">    sell.ad();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>Proxy</code>类的<code>newProxyInstance</code>方法来获取一个代理类实例。这个代理类实现了我们指定接口并且会把方法调用分发到指定的调用处理器。这个方法的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure><p>方法的三个参数含义分别如下：<br>* <code>loader</code>：定义类代理类的<code>ClassLoader</code><br>* <code>interfaces</code>：代理类实现的接口列表<br>* <code>h</code>：调用处理器，也就是上面实现了<code>InvocationHandler</code>接口的类实例</p></li></ul><h3 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h3><p><img src="https://github.com/maoyunfei/static-sources/blob/master/proxy.png?raw=true" alt="代理模式"></p><p>代理模式最大的特点就是代理类和实际业务类实现同一个接口(或继承同一父类)，代理对象持有一个实际对象的引用，外部调用时操作的是代理对象，而在代理对象的内部实现中又会去调用实际对象的操作。</p><p>Java动态代理其实内部是通过反射机制来实现的，即已知的一个对象，然后在运行时动态调用其方法，这样在调用前后做一些相应的处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是代理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是代理&quot;&gt;&lt;/a&gt; 什么是代理&lt;/h3&gt;&lt;p&gt;代理是基本的设计模式之一，给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。&lt;/p&gt;&lt;p&gt;通过使用代理，通常有两个优点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;可以隐藏委托类的实现。&lt;/li&gt;&lt;li&gt;可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Thinking in Java" scheme="https://maoyunfei.github.io/tags/Thinking-in-Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想———反射：运行时的类信息</title>
    <link href="https://maoyunfei.github.io/java/6d728b5e/"/>
    <id>https://maoyunfei.github.io/java/6d728b5e/</id>
    <published>2018-11-24T16:00:00.000Z</published>
    <updated>2018-12-06T06:27:35.330Z</updated>
    
    <content type="html"><![CDATA[<p>如果不知道某个对象的确切类型，<code>RTTI</code>可以告诉你。但是有一个限制：这个类型在编译时必须已知，这样才能使用<code>RTTI</code>识别它。换句话说，在编译时，编译器必须知道所有要通过<code>RTTI</code>来处理的类。</p><p>反射允许运行中的Java程序获取自身的信息，并且可以操作类或对象的内部属性。</p><p><code>Class</code>类和<code>java.lang.reflect</code>类库一起对反射的概念进行了支持，该类库包含了<code>Field</code>、<code>Method</code>以及<code>Constructor</code>类。这些类型的对象是由<code>JVM</code>在运行时创建的，用以表示未知类里对应的成员。这样你就可以使用<code>Constructor</code>创建新的对象，用<code>get()</code>和<code>set()</code>方法读取和修改与<code>Field</code>对象关联的字段，用<code>invoke()</code>方法调用与<code>Method</code>对象关联的方法。另外，还可以调用<code>getFields()</code>、<code>getMethods()</code>和<code>getConstructors()</code>等很便利的方法，以返回表示字段、方法以及构造器的对象的数组。这样，匿名对象的类信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。</p><a id="more"></a><p>当通过反射与一个未知类型的对象打交道时，<code>JVM</code>只是简单地检查这个对象，看它属于哪个特定的类。在用它做其他事情之前必须先加载那个类的<code>Class</code>对象。因此，那个类的 <strong><code>.class</code>文件对于<code>JVM</code>来说必须是可获取的：要么在本地机器上，要么可以通过网络获取</strong> 。所以<code>RTTI</code>和反射之间真正的区别只在于，<strong>对<code>RTTI</code>来说，编译器在编译时打开和检查<code>.class</code>文件。而对于反射机制来说，<code>.class</code>文件在编译时是不可获取的，所以是在运行时打开和检查<code>.class</code>文件</strong>。</p><h3 id="反射的基本运用"><a class="markdownIt-Anchor" href="#反射的基本运用"></a> 反射的基本运用</h3><h4 id="获取class对象"><a class="markdownIt-Anchor" href="#获取class对象"></a> 获取Class对象</h4><p><strong>方法有三种：</strong></p><ol><li>使用<code>Class</code>类的<code>forName()</code>静态方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName()</span><br></pre></td></tr></table></figure><ol start="2"><li>直接获取某一个对象的<code>class</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; klass = <span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;?&gt; classInt = Integer.TYPE;</span><br></pre></td></tr></table></figure><ol start="3"><li>调用某个对象的<code>getClass()</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"123"</span>);</span><br><span class="line">Class&lt;?&gt; klass = str.getClass();</span><br></pre></td></tr></table></figure><h4 id="判断是否为某个类的实例"><a class="markdownIt-Anchor" href="#判断是否为某个类的实例"></a> 判断是否为某个类的实例</h4><p>一般地，我们用<code>instanceof</code>关键字来判断是否为某个类的实例。同时我们也可以借助反射中<code>Class</code>对象的<code>isInstance()</code>方法，它是一个<code>native</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInstance</span><span class="params">(Object obj)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="创建实例"><a class="markdownIt-Anchor" href="#创建实例"></a> 创建实例</h4><p>通过反射来生成对象主要有两种方式。</p><ol><li>使用<code>Class</code>对象的<code>newInstance()</code>方法来创建<code>Class</code>对象对应类的实例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLass&lt;?&gt; c = String.class;</span><br><span class="line">Object str = c.newInstance();</span><br></pre></td></tr></table></figure><ol start="2"><li>先通过<code>Class</code>对象获取指定的<code>Constructor</code>对象，再调用<code>Constructor</code>对象的<code>newInstance()</code>方法来创建实例。这种方法可以用指定的构造器构造类的实例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"23333"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><h4 id="获取方法"><a class="markdownIt-Anchor" href="#获取方法"></a> 获取方法</h4><p>获取某个<code>Class</code>对象的方法集合，主要有以下几个方法。</p><ol><li><code>getDeclaredMethods()</code>方法返回类或接口声明的所有方法，包括<code>public</code>、<code>protected</code>、默认访问和<code>private</code>方法，但不包括继承的方法。</li><li><code>getMethods()</code>方法返回某个类的所有<code>public</code>方法，包括其继承类的<code>public</code>方法。</li><li><code>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code>方法返回类本身一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应<code>Class</code>的对象。</li><li><code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>方法返回类及其父类一个特定的方法。</li></ol><h4 id="获取构造器信息"><a class="markdownIt-Anchor" href="#获取构造器信息"></a> 获取构造器信息</h4><p>获取类构造器主要通过<code>Class</code>类的<code>getConstructor()</code>方法得到<code>Constructor</code>类的一个实例，而<code>Constructor</code>类有一个<code>newInstance(Object... initargs)</code>方法可以创建一个对象实例，此方法可以根据传入的参数来调用相应的<code>Constructor</code>创建对象实例。</p><h4 id="获取类的成员变量信息"><a class="markdownIt-Anchor" href="#获取类的成员变量信息"></a> 获取类的成员变量信息</h4><ol><li><code>getDeclareFields()</code>：所有已声明的成员变量，不包含父类的成员变量。</li><li><code>getFields()</code>：所有public成员变量，包含父类的public成员变量。</li><li><code>getDeclareField(String name)</code>方法返回一个类本身特定的成员变量，其中参数为成员变量名称。</li><li><code>getField(String name)</code>方法返回一个类及其父类特定的成员变量。</li></ol><h4 id="调用方法"><a class="markdownIt-Anchor" href="#调用方法"></a> 调用方法</h4><p>当我们从类中获取了一个方法后，就可以用<code>invoke()</code>方法来调用这个方法。方法原型为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">                                                        InvocationTargetException</span></span><br></pre></td></tr></table></figure><h4 id="利用反射创建数组"><a class="markdownIt-Anchor" href="#利用反射创建数组"></a> 利用反射创建数组</h4><p>数组在Java中是比较特殊的一种类型，它可以赋值给一个<code>Object</code>引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testArray</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">  Class&lt;?&gt; klass = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">  Object array = Array.newInstance(klass, <span class="number">10</span>);</span><br><span class="line">  <span class="comment">//赋值</span></span><br><span class="line">  Array.set(array, <span class="number">0</span>, <span class="string">"hello"</span>);</span><br><span class="line">  Array.set(array, <span class="number">1</span>, <span class="string">"world"</span>);</span><br><span class="line">  Array.set(array, <span class="number">2</span>, <span class="string">"java"</span>);</span><br><span class="line">  <span class="comment">//取值</span></span><br><span class="line">  System.out.println(Array.get(array, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>Array</code>类为<code>java.lang.reflect.Array</code>。我们通过<code>Array.newInstance()</code>创建数组对象，它的原型是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newInstance</span><span class="params">(Class&lt;?&gt; componentType, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> NegativeArraySizeException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newArray(componentType, length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而<code>newArray()</code>方法是一个<code>native</code>方法。<code>Array</code>类的<code>set()</code>和<code>get()</code>方法都是<code>native</code>方法。</p><h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3><p>由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。另外，反射调用方法时可以忽略访问权限检查，因此可能会破坏封装性而导致安全问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果不知道某个对象的确切类型，&lt;code&gt;RTTI&lt;/code&gt;可以告诉你。但是有一个限制：这个类型在编译时必须已知，这样才能使用&lt;code&gt;RTTI&lt;/code&gt;识别它。换句话说，在编译时，编译器必须知道所有要通过&lt;code&gt;RTTI&lt;/code&gt;来处理的类。&lt;/p&gt;&lt;p&gt;反射允许运行中的Java程序获取自身的信息，并且可以操作类或对象的内部属性。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Class&lt;/code&gt;类和&lt;code&gt;java.lang.reflect&lt;/code&gt;类库一起对反射的概念进行了支持，该类库包含了&lt;code&gt;Field&lt;/code&gt;、&lt;code&gt;Method&lt;/code&gt;以及&lt;code&gt;Constructor&lt;/code&gt;类。这些类型的对象是由&lt;code&gt;JVM&lt;/code&gt;在运行时创建的，用以表示未知类里对应的成员。这样你就可以使用&lt;code&gt;Constructor&lt;/code&gt;创建新的对象，用&lt;code&gt;get()&lt;/code&gt;和&lt;code&gt;set()&lt;/code&gt;方法读取和修改与&lt;code&gt;Field&lt;/code&gt;对象关联的字段，用&lt;code&gt;invoke()&lt;/code&gt;方法调用与&lt;code&gt;Method&lt;/code&gt;对象关联的方法。另外，还可以调用&lt;code&gt;getFields()&lt;/code&gt;、&lt;code&gt;getMethods()&lt;/code&gt;和&lt;code&gt;getConstructors()&lt;/code&gt;等很便利的方法，以返回表示字段、方法以及构造器的对象的数组。这样，匿名对象的类信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Thinking in Java" scheme="https://maoyunfei.github.io/tags/Thinking-in-Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想———类型信息之Class对象</title>
    <link href="https://maoyunfei.github.io/java/7884ea50/"/>
    <id>https://maoyunfei.github.io/java/7884ea50/</id>
    <published>2018-11-23T16:00:00.000Z</published>
    <updated>2018-12-14T09:50:29.148Z</updated>
    
    <content type="html"><![CDATA[<p>运行时类型信息(<code>Runtime Type Information</code>，<code>RTTI</code>)使得你可以在程序运行时发现和使用类型信息。Java在运行时识别对象和类的信息，主要有两种方式：一种是传统的<code>RTTI</code>，它假定我们在编译时已经知道了所有的类型；另一种是反射机制，它允许我们在运行时发现和使用类的信息。</p><p><strong>RTTI的形式包含：</strong></p><ol><li>传统的类型转换，如“<code>(Shape)</code>”，由RTTI确保类型转换的正确性，如果执行了一个错误的类型转换，就会抛出一个<code>ClassCastException</code>异常。</li><li>代表对象的类型的<code>Class</code>对象。通过查询<code>Class</code>对象可以获取运行时所需的信息。</li><li>关键字<code>instanceof</code>。它返回一个布尔值，告诉我们对象是不是某个特定类型的实例。</li></ol><a id="more"></a><h3 id="class对象"><a class="markdownIt-Anchor" href="#class对象"></a> Class对象</h3><p>所有的类都是在对其第一次使用时，动态加载到<code>JVM</code>中的，当程序创建第一个对类的静态成员的引用时，就会加载这个类。这个证明构造函数也是类的静态方法，即使在构造器之前并没有使用<code>static</code>关键字。因此，使用new操作符创建类的新对象也会被当做对类的静态成员的引用。</p><p>因此，Java程序在它开始运行之前并非被完全加载，其各个部分是在必需时才加载的。</p><p>类加载器首先检查这个类的<code>CLass</code>对象是否已经加载。如果尚未加载，默认的类加载器就会根据类名查找<code>.class</code>文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良Java代码。</p><p>一旦某个类的<code>Class</code>对象被载入内存，它就被用来创建这个类的所有对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Candy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123; System.out.println(<span class="string">"Loading Candy"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gum</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123; System.out.println(<span class="string">"Loading Gum"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cookie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &#123; System.out.println(<span class="string">"Loading Cookie"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SweetShop</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"inside main"</span>);</span><br><span class="line">    <span class="keyword">new</span> Candy();</span><br><span class="line">    System.out.println(<span class="string">"After creating Candy"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="string">"Gum"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"Couldn't find Gum"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"After Class.forName(\"Gum\")"</span>);</span><br><span class="line">    <span class="keyword">new</span> Cookie();</span><br><span class="line">    System.out.println(<span class="string">"After creating Cookie"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">inside main</span><br><span class="line">Loading Candy</span><br><span class="line">After creating Candy</span><br><span class="line">Loading Gum</span><br><span class="line">After Class.forName(<span class="string">"Gum"</span>)</span><br><span class="line">Loading Cookie</span><br><span class="line">After creating Cookie</span><br></pre></td></tr></table></figure><p>从输出中可以看到，<code>Class</code>对象仅在需要的时候才被加载，<code>static</code>初始化是在类加载时进行的。</p><h4 id="类字面常量"><a class="markdownIt-Anchor" href="#类字面常量"></a> 类字面常量</h4><p>Java还提供了另外一种方法来生成对<code>Class</code>对象的引用，即使用类字面常量。<br>如： <code>Gum.class</code>。</p><p>这样做不仅更简单，而且更安全，因为它在编译时就会受到检查。并且它根除了对<code>forName()</code>方法的调用，所以也更高效。</p><p>当使用<code>.class</code>来创建对Class对象的引用时，不会自动地初始化该<code>Class</code>对象。为了使用类而做的准备工作实际包含三个步骤：</p><ul><li><strong>加载</strong>。这是由类加载器执行的。该步骤将查找字节码，并从这些字节码中创建一个<code>Class</code>对象。</li><li><strong>链接</strong>。在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必需的话，将解析这个类创建的对其他类的所有引用。</li><li><strong>初始化</strong>。如果该类具有超类，则对其初始化，执行静态初始化器和静态代码块。</li></ul><p>初始化被延迟到了对静态方法(构造器隐式地是静态的)或者非常数静态域进行首次引用时才执行。</p><h4 id="泛化的class引用"><a class="markdownIt-Anchor" href="#泛化的class引用"></a> 泛化的Class引用</h4><p><code>Class</code>引用总是指向某个<code>Class</code>对象，它可以制造类的实例，并包含可作用于这些实例的所有方法代码。它还包含该类的静态成员，因此，<code>Class</code>引用表示的就是它所指向的对象的确切类型，而该对象便是<code>Class</code>类的一个对象。</p><p>Java SE5允许你对<code>Class</code>引用所指向的<code>Class</code>对象的类型进行限定，用到了泛型语法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClassReferences</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class intClass = <span class="keyword">int</span>.class;</span><br><span class="line">    Class&lt;Integer&gt; genericIntClass = <span class="keyword">int</span>.class;</span><br><span class="line">    genericIntClass = Integer.class;</span><br><span class="line">    intClass = <span class="keyword">double</span>.class;</span><br><span class="line">    <span class="comment">// genericIntClass = double.class; // Illegal</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="instanceof与class的等价性"><a class="markdownIt-Anchor" href="#instanceof与class的等价性"></a> instanceof与Class的等价性</h4><p>在查询类信息时，以<code>instanceof</code>的形式(即以<code>instanceof</code>的形式或<code>isInstance()</code>的形式，它们产生相同的结果)与直接比较<code>Class</code>对象有一个很重要的差别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> typeinfo</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FamilyVsExactType</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Testing x of type "</span> + x.getClass());</span><br><span class="line">    System.out.println(<span class="string">"x instanceof Base "</span> + (x <span class="keyword">instanceof</span> Base));</span><br><span class="line">    System.out.println(<span class="string">"x instanceof Derived "</span> + (x <span class="keyword">instanceof</span> Derived));</span><br><span class="line">    System.out.println(<span class="string">"Base.isInstance(x) "</span> + Base.class.isInstance(x));</span><br><span class="line">    System.out.println(<span class="string">"Derived.isInstance(x) "</span> + Derived.class.isInstance(x));</span><br><span class="line">    System.out.println(<span class="string">"x.getClass() == Base.class "</span> + (x.getClass() == Base.class));</span><br><span class="line">    System.out.println(<span class="string">"x.getClass() == Derived.class "</span> + (x.getClass() == Derived.class));</span><br><span class="line">    System.out.println(<span class="string">"x.getClass().equals(Base.class) "</span> + x.getClass().equals(Base.class));</span><br><span class="line">    System.out.println(<span class="string">"x.getClass().equals(Derived.class) "</span> + x.getClass().equals(Derived.class));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    test(<span class="keyword">new</span> Base());</span><br><span class="line">    test(<span class="keyword">new</span> Derived());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">Testing x of type typeinfo.Base</span><br><span class="line">x <span class="keyword">instanceof</span> Base <span class="keyword">true</span></span><br><span class="line">x <span class="keyword">instanceof</span> Derived <span class="keyword">false</span></span><br><span class="line">Base.isInstance(x) <span class="keyword">true</span></span><br><span class="line">Derived.isInstance(x) <span class="keyword">false</span></span><br><span class="line">x.getClass() == Base.class <span class="keyword">true</span></span><br><span class="line">x.getClass() == Derived.class <span class="keyword">false</span></span><br><span class="line">x.getClass().equals(Base.class) <span class="keyword">true</span></span><br><span class="line">x.getClass().equals(Derived.class) <span class="keyword">false</span></span><br><span class="line">Testing x of type typeinfo.Derived</span><br><span class="line">x <span class="keyword">instanceof</span> Base <span class="keyword">true</span></span><br><span class="line">x <span class="keyword">instanceof</span> Derived <span class="keyword">true</span></span><br><span class="line">Base.isInstance(x) <span class="keyword">true</span></span><br><span class="line">Derived.isInstance(x) <span class="keyword">true</span></span><br><span class="line">x.getClass() == Base.class <span class="keyword">false</span></span><br><span class="line">x.getClass() == Derived.class <span class="keyword">true</span></span><br><span class="line">x.getClass().equals(Base.class) <span class="keyword">false</span></span><br><span class="line">x.getClass().equals(Derived.class) <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code>和<code>isInstance()</code>生成的结果完全一样，<code>equals()</code>和<code>==</code>生成的结果完成一样。<code>instanceof</code>判断某个对象是否是指定类或者指定类的子类。而<code>equals()</code>比较的是实际的<code>Class</code>对象，不考虑继承。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运行时类型信息(&lt;code&gt;Runtime Type Information&lt;/code&gt;，&lt;code&gt;RTTI&lt;/code&gt;)使得你可以在程序运行时发现和使用类型信息。Java在运行时识别对象和类的信息，主要有两种方式：一种是传统的&lt;code&gt;RTTI&lt;/code&gt;，它假定我们在编译时已经知道了所有的类型；另一种是反射机制，它允许我们在运行时发现和使用类的信息。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;RTTI的形式包含：&lt;/strong&gt;&lt;/p&gt;&lt;ol&gt;&lt;li&gt;传统的类型转换，如“&lt;code&gt;(Shape)&lt;/code&gt;”，由RTTI确保类型转换的正确性，如果执行了一个错误的类型转换，就会抛出一个&lt;code&gt;ClassCastException&lt;/code&gt;异常。&lt;/li&gt;&lt;li&gt;代表对象的类型的&lt;code&gt;Class&lt;/code&gt;对象。通过查询&lt;code&gt;Class&lt;/code&gt;对象可以获取运行时所需的信息。&lt;/li&gt;&lt;li&gt;关键字&lt;code&gt;instanceof&lt;/code&gt;。它返回一个布尔值，告诉我们对象是不是某个特定类型的实例。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Thinking in Java" scheme="https://maoyunfei.github.io/tags/Thinking-in-Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想———字符串</title>
    <link href="https://maoyunfei.github.io/java/5f1ec589/"/>
    <id>https://maoyunfei.github.io/java/5f1ec589/</id>
    <published>2018-11-12T16:00:00.000Z</published>
    <updated>2018-12-06T06:27:35.314Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不可变string"><a class="markdownIt-Anchor" href="#不可变string"></a> 不可变String</h3><p><code>String</code>对象是不可变的，<code>String</code>类中每一个看起来会修改<code>String</code>值的方法，实际上都是创建了一个全新的<code>String</code>对象，以包含修改后的字符串内容，而最初的<code>String</code>对象则丝毫未动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Immutable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">upcase</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String q = <span class="string">"howdy"</span>;</span><br><span class="line">    System.out.println(q);</span><br><span class="line">    String qq = upcase(q);</span><br><span class="line">    System.out.println(qq);</span><br><span class="line">    System.out.println(q);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">howdy</span><br><span class="line">HOWDY</span><br><span class="line">howdy</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="重载-与stringbuilder"><a class="markdownIt-Anchor" href="#重载-与stringbuilder"></a> 重载 “+” 与StringBuilder</h3><p><code>String</code>对象是不可变的，不可变性会带来一定的效率问题。为<code>String</code>对象重载的“+”操作符就是一个例子。(用于 “+” 与 “+=” 是Java中仅有的两个重载过的操作符，而Java并不允许程序员重载任何操作符)。</p><p><strong>虽然编译器已经自动优化，用<code>StringBuilder</code>实现字符串拼接操作来避免生成多余对象，但是还是建议对于复杂的字符串拼接，在代码中主动使用<code>StringBuilder</code>，因为这样效率最高。</strong></p><h3 id="无意识的递归"><a class="markdownIt-Anchor" href="#无意识的递归"></a> 无意识的递归</h3><p>Java中的每个类从根本上都是继承自<code>Object</code>，标准容器类自然也不例外。因此容器类都有<code>toString()</code>方法，并且覆写了该方法，使得它生成的<code>String</code>结果能够表达容器自身，以及容器所包含的对象。例如<code>ArrayList.toString()</code>，它会遍历<code>ArrayList</code>中包含的的所有对象，调用每个元素上的<code>toString()</code>方法。</p><p>如果你希望<code>toString()</code>方法打印出对象的内存地址，也许你会考虑使用<code>this</code>关键词：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InfiniteRecursion</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"InfiniteRecursion address: "</span> + <span class="keyword">this</span> + <span class="string">"\n"</span>;  <span class="comment">//this导致递归调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;InfiniteRecursion&gt; v = <span class="keyword">new</span> ArrayList&lt;InfiniteRecursion&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      v.add(<span class="keyword">new</span> InfiniteRecursion());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你创建了<code>InfiniteRecursion</code>对象，并将其打印的时候，你会得到一串非常长的异常。如果你将该<code>InfiniteRecursion</code>对象存入一个<code>ArrayList</code>中，然后打印该<code>ArrayList</code>，你也会得到同样的异常。编译器尝试将<code>this</code>转换成一个<code>String</code>是通过调用<code>this</code>上的<code>toString()</code>方法，于是就发生了递归调用。</p><p>如果你真的想要打印出对象的内存地址，应该调用<code>Object.toString()</code>方法，这才是负责任的方法。所以，你不该使用<code>this</code>，而是应该调用<code>super.toString()</code>方法。</p><h3 id="正则表达式"><a class="markdownIt-Anchor" href="#正则表达式"></a> 正则表达式</h3><p>正则表达式是一种强大而灵活的文本处理工具。</p><h4 id="量词"><a class="markdownIt-Anchor" href="#量词"></a> 量词</h4><p>量词描述了一个模式吸收输入文本的方式：</p><ul><li>贪婪型(默认)：它的特性是一次性地读入整个字符串，如果不匹配就吐掉最右边的一个字符再匹配，直到找到匹配的字符串或字符串的长度为0为止。它的宗旨是读尽可能多的字符，所以当读到第一个匹配时就立刻返回。</li><li>勉强型(在匹配次数的特殊字符后面加一个问号)：它的特性是从字符串的左边开始，试图不读入字符串中的字符进行匹配，失败，则多读一个字符，再匹配，如此循环，当找到一个匹配时会返回该匹配的字符串，然后再次进行匹配直到字符串结束。</li><li>占有型：它和贪婪模式很相似，不同点是不匹配它不会往回吐字符再匹配。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegexMatches</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span>&#123;</span><br><span class="line">      <span class="comment">// 按指定模式在字符串查找</span></span><br><span class="line">      String line = <span class="string">"This order was placed for QT3000! OK?"</span>;</span><br><span class="line">      String pattern = <span class="string">"(\\D*)(\\d+)(.*)"</span>;</span><br><span class="line">      <span class="comment">// 创建 Pattern 对象</span></span><br><span class="line">      Pattern r = Pattern.compile(pattern);</span><br><span class="line">      <span class="comment">// 现在创建 matcher 对象</span></span><br><span class="line">      Matcher m = r.matcher(line);</span><br><span class="line">      <span class="keyword">if</span> (m.find( )) &#123;</span><br><span class="line">         System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">0</span>) );</span><br><span class="line">         System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">1</span>) );</span><br><span class="line">         System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">2</span>) );</span><br><span class="line">         System.out.println(<span class="string">"Found value: "</span> + m.group(<span class="number">3</span>) );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">"NO MATCH"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">Found value: This order was placed <span class="keyword">for</span> QT3000! OK?</span><br><span class="line">Found value: This order was placed <span class="keyword">for</span> QT</span><br><span class="line">Found value: <span class="number">3000</span></span><br><span class="line">Found value: ! OK?</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;不可变string&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#不可变string&quot;&gt;&lt;/a&gt; 不可变String&lt;/h3&gt;&lt;p&gt;&lt;code&gt;String&lt;/code&gt;对象是不可变的，&lt;code&gt;String&lt;/code&gt;类中每一个看起来会修改&lt;code&gt;String&lt;/code&gt;值的方法，实际上都是创建了一个全新的&lt;code&gt;String&lt;/code&gt;对象，以包含修改后的字符串内容，而最初的&lt;code&gt;String&lt;/code&gt;对象则丝毫未动。&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Immutable&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;upcase&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String s)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; s.toUpperCase();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String q = &lt;span class=&quot;string&quot;&gt;&quot;howdy&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(q);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String qq = upcase(q);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(qq);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(q);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//output&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;howdy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;HOWDY&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;howdy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Thinking in Java" scheme="https://maoyunfei.github.io/tags/Thinking-in-Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想———标准异常</title>
    <link href="https://maoyunfei.github.io/java/bac16ae/"/>
    <id>https://maoyunfei.github.io/java/bac16ae/</id>
    <published>2018-11-10T16:00:00.000Z</published>
    <updated>2018-12-06T06:31:37.976Z</updated>
    
    <content type="html"><![CDATA[<p><code>Throwable</code>类被用来表示任何可以作为异常被抛出的类。从<code>Throwable</code>继承可分为两种类型：<code>Error</code>用来表示编译时和系统错误，一般不用关心；<code>Exception</code>是可以被抛出的的基本类型，通常是程序员所关心的。<code>Exception</code>又可以分为受检查的异常和未受检查的异常，未受检查的异常也叫运行时异常，受检查的异常必须要处理。</p><a id="more"></a><p><img src="https://github.com/maoyunfei/static-sources/blob/master/exception.png?raw=true" alt="标准异常"></p><h3 id="常见的exception和error"><a class="markdownIt-Anchor" href="#常见的exception和error"></a> 常见的Exception和Error</h3><ul><li><strong>Checked exceptions</strong><ul><li><code>IOException</code></li></ul></li><li><strong>Unchecked exceptions/Runtime exceptions</strong><ul><li><code>ArrayIndexOutOfBoundsException</code></li><li><code>ClassCastException</code></li><li><code>IllegalArgumentException</code></li><li><code>IllegalStateException</code></li><li><code>NullPointerException</code></li><li><code>NumberFormatException</code></li></ul></li><li><strong>Errors</strong><ul><li><code>StackOverflowError</code></li><li><code>NoClassDefDoundError</code></li><li><code>OutOfMemoryError</code></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Throwable&lt;/code&gt;类被用来表示任何可以作为异常被抛出的类。从&lt;code&gt;Throwable&lt;/code&gt;继承可分为两种类型：&lt;code&gt;Error&lt;/code&gt;用来表示编译时和系统错误，一般不用关心；&lt;code&gt;Exception&lt;/code&gt;是可以被抛出的的基本类型，通常是程序员所关心的。&lt;code&gt;Exception&lt;/code&gt;又可以分为受检查的异常和未受检查的异常，未受检查的异常也叫运行时异常，受检查的异常必须要处理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Thinking in Java" scheme="https://maoyunfei.github.io/tags/Thinking-in-Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想———简单的容器分类</title>
    <link href="https://maoyunfei.github.io/java/92b4f9c/"/>
    <id>https://maoyunfei.github.io/java/92b4f9c/</id>
    <published>2018-11-09T16:00:00.000Z</published>
    <updated>2018-12-06T06:31:37.941Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://github.com/maoyunfei/static-sources/blob/master/%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB.png?raw=true" alt="简单的容器分类"></p><a id="more"></a><p> </p><p>从上图可以看出，其实只有四种容器：<code>Map</code>、<code>List</code>、<code>Set</code>和<code>Queue</code>。常用的容器用黑色粗线框表示。</p><p>点线框表示接口，实线框表示具体的类。带有空心箭头的点线表示一个特定的类实现了一个接口，带有空心箭头的实线表示一个特定的类继承了一个类，实心箭头表示某个类可以生成箭头所指向类的对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://github.com/maoyunfei/static-sources/blob/master/%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB.png?raw=true&quot; alt=&quot;简单的容器分类&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Thinking in Java" scheme="https://maoyunfei.github.io/tags/Thinking-in-Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想———内部类</title>
    <link href="https://maoyunfei.github.io/java/385f254c/"/>
    <id>https://maoyunfei.github.io/java/385f254c/</id>
    <published>2018-10-29T16:00:00.000Z</published>
    <updated>2018-12-06T06:27:35.321Z</updated>
    
    <content type="html"><![CDATA[<p>可以将一个类的定义放到另一个类的定义内部，这就是内部类。</p><h3 id="链接到外部类"><a class="markdownIt-Anchor" href="#链接到外部类"></a> 链接到外部类</h3><p>当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。</p><h3 id="使用this与new"><a class="markdownIt-Anchor" href="#使用this与new"></a> 使用.this与.new</h3><p>如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟<code>.this</code>。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotThis</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"DotThis.f()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DotThis <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> DotThis.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DotThis dt = <span class="keyword">new</span> DotThis();</span><br><span class="line">    DotThis.Inner dti = dt.inner();</span><br><span class="line">    dti.outer().f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">DotThis.f()</span><br></pre></td></tr></table></figure><p>由外部类对象去创建其某个内部类的对象，必须在new表达式中提供外部对象的引用，这需要使用<code>.new</code>语法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotNew</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DotNew dn = <span class="keyword">new</span> DotNew();</span><br><span class="line">    DotNew.Inner dni = dn.new Inner();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在拥有外部类对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗地连接到创建它的外部类对象上。但是，如果创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。</p><h3 id="匿名内部类"><a class="markdownIt-Anchor" href="#匿名内部类"></a> 匿名内部类</h3><p>如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是final的。</p><h4 id="无参构造"><a class="markdownIt-Anchor" href="#无参构造"></a> 无参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Contents</span> </span>&#123;</span><br><span class="line">  piblic <span class="keyword">int</span> i;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParCel7</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Contents <span class="title">contents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Contents() &#123;  <span class="comment">//无参构造</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">11</span>;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Parcel7 p = <span class="keyword">new</span> Parcel7();</span><br><span class="line">    Contents c = p.contents();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有参构造"><a class="markdownIt-Anchor" href="#有参构造"></a> 有参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapping</span> </span>&#123;</span><br><span class="line">  piblic <span class="keyword">int</span> i;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parcel8</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Wrapping <span class="title">wrapping</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Wrapping(x) &#123; <span class="comment">//有参构造</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.value() * <span class="number">47</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Pracel8 p = <span class="keyword">new</span> Pracel8();</span><br><span class="line">    Wrapping w = p.wrapping(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="带实例初始化"><a class="markdownIt-Anchor" href="#带实例初始化"></a> 带实例初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Parcel10 &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Destination <span class="title">destination</span><span class="params">(<span class="keyword">final</span> String dest, <span class="keyword">final</span> <span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Destination() &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">      &#123;</span><br><span class="line">        cost = Math.round(price); <span class="comment">//实例初始化</span></span><br><span class="line">        <span class="keyword">if</span>(cost &gt; <span class="number">100</span>)&#123;</span><br><span class="line">          System.out.println(<span class="string">"Over budget!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">private</span> String label = dest; <span class="comment">//实例初始化</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">readLabel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> label;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Parcel10 p = <span class="keyword">new</span> Parcel10();</span><br><span class="line">    Destination d = p.destination(<span class="string">"Tasmania"</span>, <span class="number">101.395F</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">Over budget!</span><br></pre></td></tr></table></figure><h3 id="嵌套类静态内部类"><a class="markdownIt-Anchor" href="#嵌套类静态内部类"></a> 嵌套类（静态内部类）</h3><p>如果将内部类声明为<code>static</code>，则称为嵌套类。</p><ul><li>要创建嵌套类的对象，并不需要其外围类的对象。</li><li>不能从嵌套类的对象中访问非静态的外围类对象。</li></ul><h4 id="接口内部的类"><a class="markdownIt-Anchor" href="#接口内部的类"></a> 接口内部的类</h4><p>因为接口中的任何类都自动地是<code>public</code>和<code>static</code>的，因此接口中的类是嵌套类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">ClassInInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">howdy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Howdy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> Test().howdy();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">Howdy!</span><br></pre></td></tr></table></figure><h3 id="从多层嵌套类中访问外部类的成员"><a class="markdownIt-Anchor" href="#从多层嵌套类中访问外部类的成员"></a> 从多层嵌套类中访问外部类的成员</h3><p>一个内部类被嵌套多少层并不重要，它能透明地访问所有它所嵌入的外围类的所有成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MNA</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        g();</span><br><span class="line">        f();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiNestingAccess</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MNA mna = <span class="keyword">new</span> MNA();</span><br><span class="line">    MNA.A mnaa = mna.new A();</span><br><span class="line">    MNA.A.B mnaab = mnaa.new B();</span><br><span class="line">    mnaab.h();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部类的继承"><a class="markdownIt-Anchor" href="#内部类的继承"></a> 内部类的继承</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WithInner</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritInner</span> <span class="keyword">extends</span> <span class="title">WithInner</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line">  InheritInner(WithInner wi)&#123;  <span class="comment">//有参构造</span></span><br><span class="line">    wi.<span class="keyword">super</span>();               <span class="comment">//重要</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    WithInner wi = <span class="keyword">new</span> WithInner();</span><br><span class="line">    InheritInner ii = <span class="keyword">new</span> InheritInner(wi);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能使用默认构造器，必须使用有参构造器，需要传递一个指向外围类对象的引用，同时必须在构造器内使用如下语法：<br><code>enclosingClassReference.super()</code>，这样才提供了必要的引用。</p><h3 id="内部类可以被覆盖吗"><a class="markdownIt-Anchor" href="#内部类可以被覆盖吗"></a> 内部类可以被覆盖吗</h3><p>覆盖内部类就好像它是外围类的一个方法，其实并不起什么作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Yolk y;</span><br><span class="line">  <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Egg.Yolk()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"New Egg()"</span>);</span><br><span class="line">    y = <span class="keyword">new</span> Yolk();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg</span> <span class="keyword">extends</span> <span class="title">Egg</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"BigEgg.Yolk()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> BigEgg();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="function">New <span class="title">Egg</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Egg.<span class="title">Yolk</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>当继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化。这两个内部类是完全独立的两个实体，各自在自己的命名空间内。</p><p>但是，可以明确地继承某个内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Egg2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Egg2.Yolk()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Egg2.Yolk.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> Yolk y = <span class="keyword">new</span> Yolk();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Egg2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"New Egg2()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertYolk</span><span class="params">(Yolk yy)</span> </span>&#123;</span><br><span class="line">    y = yy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    y.f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigEgg2</span> <span class="keyword">extends</span> <span class="title">Egg2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yolk</span> <span class="keyword">extends</span> <span class="title">Egg2</span>.<span class="title">Yolk</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Yolk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"BigEgg2.Yolk()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"BigEgg2.Yolk.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BigEgg2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    insertYolk(<span class="keyword">new</span> Yolk());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Egg2 e2 = <span class="keyword">new</span> BigEgg2();</span><br><span class="line">    e2.g();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">Egg2.Yolk()</span><br><span class="line"><span class="function">New <span class="title">Egg2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Egg2.<span class="title">Yolk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BigEgg2.<span class="title">Yolk</span><span class="params">()</span></span></span><br><span class="line"><span class="function">BigEgg2.Yolk.<span class="title">f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="局部内部类"><a class="markdownIt-Anchor" href="#局部内部类"></a> 局部内部类</h3><p>可以在代码块或者方法体内创建内部类，叫做局部内部类。局部内部类不能有访问说明符，因为它不是外围类的一部分；但是它可以访问当前代码块内的常量，以及此外围类的所有成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function">Counter <span class="title">getCounter</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//局部内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LocalCounter</span> <span class="keyword">implements</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">LocalCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LocalCounter()"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">return</span> count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LocalCounter();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Counter <span class="title">getCounter2</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//匿名内部类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Counter() &#123;</span><br><span class="line">      &#123;</span><br><span class="line">        System.out.println(<span class="string">"Counter()"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">return</span> count++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LocalInnerClass lic = <span class="keyword">new</span> LocalInnerClass();</span><br><span class="line">    Counter c1 = lic.getCount(<span class="string">"Local inner "</span>);</span><br><span class="line">    Counter c2 = lic.getCount2(<span class="string">"Anonymous inner "</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      System.out.println(c1.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">      System.out.println(c2.next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">LocalCounter()</span><br><span class="line">Counter()</span><br><span class="line">Local inner <span class="number">0</span></span><br><span class="line">Local inner <span class="number">1</span></span><br><span class="line">Local inner <span class="number">2</span></span><br><span class="line">Local inner <span class="number">3</span></span><br><span class="line">Local inner <span class="number">4</span></span><br><span class="line">Anonymous inner <span class="number">5</span></span><br><span class="line">Anonymous inner <span class="number">6</span></span><br><span class="line">Anonymous inner <span class="number">7</span></span><br><span class="line">Anonymous inner <span class="number">8</span></span><br><span class="line">Anonymous inner <span class="number">9</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可以将一个类的定义放到另一个类的定义内部，这就是内部类。&lt;/p&gt;&lt;h3 id=&quot;链接到外部类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#链接到外部类&quot;&gt;&lt;/a&gt; 链接到外部类&lt;/h3&gt;&lt;p&gt;当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。&lt;/p&gt;&lt;h3 id=&quot;使用this与new&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用this与new&quot;&gt;&lt;/a&gt; 使用.this与.new&lt;/h3&gt;&lt;p&gt;如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟&lt;code&gt;.this&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Thinking in Java" scheme="https://maoyunfei.github.io/tags/Thinking-in-Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想———多态</title>
    <link href="https://maoyunfei.github.io/java/73b264e5/"/>
    <id>https://maoyunfei.github.io/java/73b264e5/</id>
    <published>2018-10-13T16:00:00.000Z</published>
    <updated>2018-12-06T06:27:35.340Z</updated>
    
    <content type="html"><![CDATA[<p>多态也称作动态绑定、后期绑定或运行时绑定。</p><h3 id="方法调用绑定"><a class="markdownIt-Anchor" href="#方法调用绑定"></a> 方法调用绑定</h3><p>将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定，叫做前期绑定。在运行时根据对象的类型进行绑定叫做后期绑定。后期绑定也叫做动态绑定或运行时绑定。</p><p>Java中除了<code>static</code>方法和<code>final</code>方法(<code>private</code>方法属于<code>final</code>方法)之外，其他所有的方法都是后期绑定。</p><a id="more"></a><h3 id="缺陷覆盖私有方法"><a class="markdownIt-Anchor" href="#缺陷覆盖私有方法"></a> 缺陷：“覆盖”私有方法</h3><p>只有非<code>private</code>方法才可以被覆盖；但是还需要密切注意覆盖<code>private</code>方法的现象，这时虽然编译器不会报错，但是也不会按照我们所期望的来执行。确切地说，在导出类(子类)中，对于基类中的<code>private</code>方法，最好采用不同的名字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateOverride</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"private f()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PrivateOverride po = <span class="keyword">new</span> Derived();</span><br><span class="line">    po.f();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">PrivateOverride</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"public f()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="缺陷-域与静态方法"><a class="markdownIt-Anchor" href="#缺陷-域与静态方法"></a> 缺陷： 域与静态方法</h3><p>任何域访问操作都将由编译器解析，因此不是多态的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> field;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> field = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> field;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSuperField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.field;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldAccess</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Super sup = <span class="keyword">new</span> Sub();</span><br><span class="line">    System.out.println(<span class="string">"sup field = "</span> + sup.field + <span class="string">", sup.getField() = "</span> + sup.getField());</span><br><span class="line">    Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">    System.out.println(<span class="string">"sub field = "</span> + sub.field + <span class="string">", sub.getField() = "</span> + sub.getField() + <span class="string">", sub.getSuperField() = "</span> + sub.getSuperField());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">sup.field = <span class="number">0</span>, sup.getField() = <span class="number">1</span></span><br><span class="line">sub.field = <span class="number">1</span>, sub.getField() = <span class="number">1</span>, sub.getSuperField() = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>只有普通的方法调用可以是多态的，如果某个方法是静态的，它的行为就不具有多态性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Base staticGet()"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dynamicGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Base dynamicGet()"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticSub</span> <span class="keyword">extends</span> <span class="title">StaticSuper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">staticget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Derived staticGet()"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">dynamicGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Derived dynamicGet()"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticPolymorphism</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StaticSuper sup = <span class="keyword">new</span> StaticSub();</span><br><span class="line">    System.out.println(sup.staticGet());</span><br><span class="line">    System.out.println(sup.dynamicGet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="function">Base <span class="title">staticGet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Derived <span class="title">dynamicGet</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="构造器内部的多态方法的行为"><a class="markdownIt-Anchor" href="#构造器内部的多态方法的行为"></a> 构造器内部的多态方法的行为</h3><p>在一般的方法内部，动态绑定的调用是在运行时才决定的，因此对象无法知道它是属于方法所在的那个类，还是属于那个类的导出类。</p><p>如果要调用构造器内部的一个动态绑定方法，就要用到那个方法的被覆盖后的定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Glyph.draw()"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  Glyph() &#123;</span><br><span class="line">    System.out.println(<span class="string">"Glyph() before draw()"</span>);</span><br><span class="line">    draw();</span><br><span class="line">    System.out.println(<span class="string">"Glyph() after draw()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoundGlyph</span> <span class="keyword">extends</span> <span class="title">Glyph</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> radius = <span class="number">1</span>;</span><br><span class="line">  RoundGlyph(<span class="keyword">int</span> r) &#123;</span><br><span class="line">    radius = r;</span><br><span class="line">    System.out.println(<span class="string">"RoundGlyph.RoundGlyph(). radius = "</span> + radius;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"RoundGlyph.draw(). radius = "</span> + radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">                       </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolyConstructors</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> RoundGlyph(<span class="number">5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">                       </span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">Glyph() <span class="function">before <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">RoundGlyph.<span class="title">draw</span><span class="params">()</span>. radius </span>= <span class="number">0</span></span><br><span class="line">Glyph() <span class="function">after <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">RoundGlyph.<span class="title">draw</span><span class="params">()</span>. radius </span>= <span class="number">1</span></span><br></pre></td></tr></table></figure><p>编写构造器时有一条有效的准则：“用尽可能简单的方法使对象进入正常状态；如果可以的话，避免调用其他方法”。<br>在构造器内唯一能够安全调用的那些方法是基类中的<code>final</code>方法(也适用于<code>private</code>方法，它们自动属于<code>final</code>方法)。这些方法不能被覆盖，因此也就不会出现令人惊讶的问题。</p><h3 id="协变返回类型"><a class="markdownIt-Anchor" href="#协变返回类型"></a> 协变返回类型</h3><p>协变返回类型指的是子类中的成员函数的返回值类型不必严格等同于父类中被重写的成员函数的返回值类型，而可以是更 “狭窄” 的类型。<br>Java 5.0添加了对协变返回类型的支持，即子类覆盖基类方法时，返回的类型可以是基类方法返回类型的子类。协变返回类型允许返回更为具体的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Grain"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wheat</span> <span class="keyword">extends</span> <span class="title">Grain</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Wheat"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mill</span> </span>&#123;</span><br><span class="line">  <span class="function">Grain <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Grain();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WheatMill</span> <span class="keyword">extends</span> <span class="title">Mill</span> </span>&#123;</span><br><span class="line">  <span class="function">Wheat <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Wheat();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CovariantReturn</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Mill m = <span class="keyword">new</span> Mill();</span><br><span class="line">    Grain g = m,process();</span><br><span class="line">    System.out.println(g);</span><br><span class="line">    m = <span class="keyword">new</span> WheatMill();</span><br><span class="line">    g = m.process();</span><br><span class="line">    System.out.println(g);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">Grain</span><br><span class="line">Wheat</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;多态也称作动态绑定、后期绑定或运行时绑定。&lt;/p&gt;&lt;h3 id=&quot;方法调用绑定&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#方法调用绑定&quot;&gt;&lt;/a&gt; 方法调用绑定&lt;/h3&gt;&lt;p&gt;将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定，叫做前期绑定。在运行时根据对象的类型进行绑定叫做后期绑定。后期绑定也叫做动态绑定或运行时绑定。&lt;/p&gt;&lt;p&gt;Java中除了&lt;code&gt;static&lt;/code&gt;方法和&lt;code&gt;final&lt;/code&gt;方法(&lt;code&gt;private&lt;/code&gt;方法属于&lt;code&gt;final&lt;/code&gt;方法)之外，其他所有的方法都是后期绑定。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Thinking in Java" scheme="https://maoyunfei.github.io/tags/Thinking-in-Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想———类的继承</title>
    <link href="https://maoyunfei.github.io/java/e1123076/"/>
    <id>https://maoyunfei.github.io/java/e1123076/</id>
    <published>2018-09-29T16:00:00.000Z</published>
    <updated>2018-12-06T06:31:38.010Z</updated>
    
    <content type="html"><![CDATA[<h3 id="继承语法"><a class="markdownIt-Anchor" href="#继承语法"></a> 继承语法</h3><p>在创建子类的对象时，Java虚拟机首先执行父类的构造方法，然后再执行子类的构造方法。在多级继承的情况下，将从继承树的最上层的父类开始，依次执行各个类的构造方法，这可以保证子类对象从所有直接或间接父类中继承的实例变量都别正确地初始化。</p><ul><li><strong>子类的所有构造方法内部，第一行会(隐式)自动先调用父类的无参构造函数(<code>super()</code>)</strong></li><li><strong>如果子类构造方法第一行显式调用了父类构造方法，系统就不再调用父类的无参构造函数</strong></li><li><strong>子类的构造方法中调用父类的构造函数必须写在第一行，如果父类没有无参构造函数，子类必须在构造方法中显式调用父类的有参构造函数</strong></li></ul><a id="more"></a><h3 id="继承的初始化顺序"><a class="markdownIt-Anchor" href="#继承的初始化顺序"></a> 继承的初始化顺序</h3><p>‼️ <strong>初始化顺序：父类的静态变量(父类的静态代码块) --&gt; 子类的静态变量(子类的静态代码快) --&gt; 父类的非静态变量(父类的非静态代码块) --&gt; 父类的构造函数 --&gt; 子类的非静态变量（子类的非静态代码块）–&gt; 子类的构造函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hts.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Child c=<span class="keyword">new</span> Child();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PrintMessage a=<span class="keyword">new</span> PrintMessage(<span class="string">"父类静态成员被初始化"</span>);</span><br><span class="line">    <span class="keyword">private</span> PrintMessage b=<span class="keyword">new</span> PrintMessage(<span class="string">"父类非静态成员被初始化"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类的静态代码块被执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"父类的非静态代码块被执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类的构造方法被执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PrintMessage a1=<span class="keyword">new</span> PrintMessage(<span class="string">"子类静态成员被初始化"</span>);</span><br><span class="line">    <span class="keyword">private</span> PrintMessage b1=<span class="keyword">new</span> PrintMessage(<span class="string">"子类非静态成员被初始化"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"子类的静态代码块被执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"子类的非静态代码块被执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类的构造函数被执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintMessage</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintMessage</span><span class="params">(String mes)</span></span>&#123;</span><br><span class="line">        System.out.println(mes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">父类静态成员被初始化</span><br><span class="line">父类的静态代码块被执行</span><br><span class="line">子类静态成员被初始化</span><br><span class="line">子类的静态代码块被执行</span><br><span class="line">父类非静态成员被初始化</span><br><span class="line">父类的非静态代码块被执行</span><br><span class="line">父类的构造方法被执行</span><br><span class="line">子类非静态成员被初始化</span><br><span class="line">子类的非静态代码块被执行</span><br><span class="line">子类的构造函数被执行</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;继承语法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#继承语法&quot;&gt;&lt;/a&gt; 继承语法&lt;/h3&gt;&lt;p&gt;在创建子类的对象时，Java虚拟机首先执行父类的构造方法，然后再执行子类的构造方法。在多级继承的情况下，将从继承树的最上层的父类开始，依次执行各个类的构造方法，这可以保证子类对象从所有直接或间接父类中继承的实例变量都别正确地初始化。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;子类的所有构造方法内部，第一行会(隐式)自动先调用父类的无参构造函数(&lt;code&gt;super()&lt;/code&gt;)&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;如果子类构造方法第一行显式调用了父类构造方法，系统就不再调用父类的无参构造函数&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;子类的构造方法中调用父类的构造函数必须写在第一行，如果父类没有无参构造函数，子类必须在构造方法中显式调用父类的有参构造函数&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Thinking in Java" scheme="https://maoyunfei.github.io/tags/Thinking-in-Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想———访问权限控制</title>
    <link href="https://maoyunfei.github.io/java/65045805/"/>
    <id>https://maoyunfei.github.io/java/65045805/</id>
    <published>2018-09-28T16:00:00.000Z</published>
    <updated>2018-12-06T06:31:38.001Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java访问权限"><a class="markdownIt-Anchor" href="#java访问权限"></a> Java访问权限</h3><p>下表为Java访问控制符的含义和使用情况</p><table><thead><tr><th></th><th style="text-align:center">同一类</th><th style="text-align:center">同一包中的类</th><th style="text-align:center">子类</th><th style="text-align:center">其他包中的类</th></tr></thead><tbody><tr><td><code>public</code></td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td></tr><tr><td><code>protected</code></td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✖️</td></tr><tr><td><code>default</code></td><td style="text-align:center">✔️</td><td style="text-align:center">✔️</td><td style="text-align:center">✖️</td><td style="text-align:center">✖️</td></tr><tr><td><code>private</code></td><td style="text-align:center">✔️</td><td style="text-align:center">✖️</td><td style="text-align:center">✖️</td><td style="text-align:center">✖️</td></tr></tbody></table><p><code>public</code> &gt; <code>protected</code> &gt; 同包(<code>default</code>) &gt; <code>private</code></p><a id="more"></a><p>‼️ <strong>Java的访问控制是停留在编译层的，也就是它不会在<code>.class</code>文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员或方法的。</strong></p><h3 id="利用反射调用私有方法-访问私有属性"><a class="markdownIt-Anchor" href="#利用反射调用私有方法-访问私有属性"></a> 利用反射调用私有方法、访问私有属性</h3><p>利用反射，首先是<code>Class</code>对象的获取，之后是<code>Method</code>和<code>Field</code>对象的获取。<br><code>getMethod()</code>方法返回的是<code>public</code>的<code>Method</code>对象，<br>而<code>getDeclaredMethod()</code>返回的<code>Method</code>对象可以是非<code>public</code>的。<code>Field</code>的方法同理。</p><p>访问私有属性和方法，在使用前要通过<code>AccessibleObject</code>类（<code>Constructor</code>、 <code>Field</code>和<code>Method</code>类的基类）中的<code>setAccessible()</code>方法来抑制Java访问权限的检查。</p><h4 id="实例调用私有方法"><a class="markdownIt-Anchor" href="#实例调用私有方法"></a> 实例：调用私有方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">sayHello</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello: "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPrivate</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        PrivateClass p = <span class="keyword">new</span> PrivateClass();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; classType = p.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Method对象</span></span><br><span class="line">        Method method = classType.getDeclaredMethod(<span class="string">"sayHello"</span>,</span><br><span class="line">                <span class="keyword">new</span> Class[] &#123; String.class &#125;);</span><br><span class="line"></span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>); <span class="comment">// 抑制Java的访问控制检查</span></span><br><span class="line">        <span class="comment">// 如果不加上上面这句，将会Error: TestPrivate can not access a member of class PrivateClass with modifiers "private"</span></span><br><span class="line">        String str = (String) method.invoke(p, <span class="keyword">new</span> Object[] &#123; <span class="string">"zhangsan"</span> &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例访问私有属性"><a class="markdownIt-Anchor" href="#实例访问私有属性"></a> 实例：访问私有属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateClass2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"zhangsan"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPrivate2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        PrivateClass2 p = <span class="keyword">new</span> PrivateClass2();</span><br><span class="line">        Class&lt;?&gt; classType = p.getClass();</span><br><span class="line"></span><br><span class="line">        Field field = classType.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line"></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>); <span class="comment">// 抑制Java对修饰符的检查</span></span><br><span class="line">        field.set(p, <span class="string">"lisi"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java访问权限&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java访问权限&quot;&gt;&lt;/a&gt; Java访问权限&lt;/h3&gt;&lt;p&gt;下表为Java访问控制符的含义和使用情况&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th style=&quot;text-align:center&quot;&gt;同一类&lt;/th&gt;&lt;th style=&quot;text-align:center&quot;&gt;同一包中的类&lt;/th&gt;&lt;th style=&quot;text-align:center&quot;&gt;子类&lt;/th&gt;&lt;th style=&quot;text-align:center&quot;&gt;其他包中的类&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;public&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;protected&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✖️&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;default&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✖️&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✖️&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;private&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✔️&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✖️&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✖️&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;✖️&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;public&lt;/code&gt; &amp;gt; &lt;code&gt;protected&lt;/code&gt; &amp;gt; 同包(&lt;code&gt;default&lt;/code&gt;) &amp;gt; &lt;code&gt;private&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Thinking in Java" scheme="https://maoyunfei.github.io/tags/Thinking-in-Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编程思想———初始化与清理</title>
    <link href="https://maoyunfei.github.io/java/a2c6556/"/>
    <id>https://maoyunfei.github.io/java/a2c6556/</id>
    <published>2018-09-27T16:00:00.000Z</published>
    <updated>2018-12-06T06:31:37.967Z</updated>
    
    <content type="html"><![CDATA[<h3 id="默认构造器"><a class="markdownIt-Anchor" href="#默认构造器"></a> 默认构造器</h3><p>默认构造器(又名无参构造器)是没有形式参数的，它的作用是创建一个“默认对象”。如果你写的类中没有构造器，则编译器会自动帮你创建一个默认构造器。</p><p>如果已经定义了一个构造器，编译器就不会帮你自动创建默认构造器。</p><a id="more"></a><h3 id="在构造器中调用构造器"><a class="markdownIt-Anchor" href="#在构造器中调用构造器"></a> 在构造器中调用构造器</h3><p>可能为一个类写了多个构造器，有时可能想在一个构造器中调用另一个构造器，以避免重复代码。可用<code>this</code>关键字做到这一点。</p><p><strong>尽管可以用<code>this</code>调用一个构造器，但却不能调用两个。此外，必须将构造器调用置于最起始处，否则编译会报错。</strong></p><h3 id="垃圾回收"><a class="markdownIt-Anchor" href="#垃圾回收"></a> 垃圾回收</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>垃圾回收器会特别对待覆盖了<code>finalize()</code>方法的对象。一般情况下，在垃圾回收期间，一个无法触及的对象会立即被销毁。不过，覆盖了<code>finalize()</code>方法的对象会被移动到一个队列(F-Queue)里，一个独立的线程遍历这个队列，调用每一个对象的<code>finalize()</code>方法。在<code>finalize()</code>方法调用结束之后，这些对象才成为真正的垃圾，等待下一轮垃圾回收。</p><p>一个对象的<code>finalize()</code>方法只会被调用一次，而且<code>finalize()</code>被调用不意味着gc会立即回收该对象，所以有可能调用<code>finalize()</code>后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会调用<code>finalize()</code>，产生问题。</p><p>不该将<code>finalize()</code>作为通用的清理方法，<code>finalize()</code>是一个用于释放非Java资源的方法。</p><p>之所以要有<code>finalize()</code>，是由于在分配内存时可能采用了类似C语言中的做法，而非Java中的通常做法。这种情况主要发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非本地代码的方式。</p><h3 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h3><p>初始化的顺序是先静态对象（如果它们尚未因前面的对象创建过程而被初始化），而后是“非静态”对象。<strong>静态初始化动作只进行一次。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;默认构造器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#默认构造器&quot;&gt;&lt;/a&gt; 默认构造器&lt;/h3&gt;&lt;p&gt;默认构造器(又名无参构造器)是没有形式参数的，它的作用是创建一个“默认对象”。如果你写的类中没有构造器，则编译器会自动帮你创建一个默认构造器。&lt;/p&gt;&lt;p&gt;如果已经定义了一个构造器，编译器就不会帮你自动创建默认构造器。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://maoyunfei.github.io/categories/java/"/>
    
    
      <category term="Thinking in Java" scheme="https://maoyunfei.github.io/tags/Thinking-in-Java/"/>
    
  </entry>
  
  <entry>
    <title>第一章、分布式架构</title>
    <link href="https://maoyunfei.github.io/distributed/b1bde3f7/"/>
    <id>https://maoyunfei.github.io/distributed/b1bde3f7/</id>
    <published>2018-05-30T16:00:00.000Z</published>
    <updated>2018-12-06T06:31:38.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从集中式到分布式"><a class="markdownIt-Anchor" href="#从集中式到分布式"></a> 从集中式到分布式</h2><h3 id="集中式的特点"><a class="markdownIt-Anchor" href="#集中式的特点"></a> 集中式的特点</h3><p>所谓的集中式系统就是指由一台或多台主计算机组成中心节点，数据集中存储于这个中心节点中，并且整个系统的所有业务单元都集中部署在这个中心节点上，系统的所有功能均由其集中处理。</p><p>集中式系统最大的特点就是部署结构简单。由于集中式系统往往基于底层性能卓越的大型主机，因此无需考虑如何对服务进行多个节点的部署，也就不用考虑多个节点之间的分布式协作问题。</p><a id="more"></a><h3 id="分布式的特点"><a class="markdownIt-Anchor" href="#分布式的特点"></a> 分布式的特点</h3><p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p><p>严格地讲，同一个分布式系统中的计算机在空间部署上是可以随意分布的，这些计算机可能被放在不同的机柜上，也可能在不同的机房中，甚至分布在不同的城市。</p><p>无论如何，一个标准的分布式系统在没有任何特定业务逻辑约束的情况下，都会有如下几个特征。</p><ul><li><p>分布性</p><p>分布式系统中的多台计算机都会在空间上随意分布，同时，机器的分布情况也会随时变动。</p></li><li><p>对等性</p><p>分布式系统中的计算机没有主/从之分，既没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有计算机节点都是对等的。</p><p>副本(<code>replica</code>)是分布式系统最常见的概念之一，指的是分布式系统对数据和服务提供的一种冗余方式。在常见的分布式系统中，为了对外提供高可用的服务，我们往往会对数据和服务进行副本处理。数据副本是指在不同的节点上持久化同一份数据，当某一个节点上存储的数据丢失时，可以从副本上读取到该数据，这是解决分布式系统数据丢失问题最为有效的手段。另一类副本是服务副本，指多个节点提供同样的服务，每个节点都有能力接收来自外部的请求并进行相应的处理。</p></li><li><p>并发性</p><p>在一个计算机网络中，程序运行过程中的并发性操作是非常常见的行为，例如同一个分布式系统中的多个节点，可能会并发地操作一些共享的资源，诸如数据库或分布式存储等，如何准确并高效地协调分布式并发操作也成为了分布式系统架构个设计中最大的挑战之一。</p></li><li><p>缺乏全局时钟</p><p>在分布式系统中，很难定义两个事件究竟谁先谁后，原因就是因为分布式系统缺乏一个全局的时钟序列控制。</p></li><li><p>故障总是会发生</p><p>组成分布式系统的所有计算机，都有可能发生任何形式的故障。一个被大量工程实践所检验过的黄金定理是：任何在设计阶段考虑到的异常情况，一定会在系统实际运行中发生，并且，在系统实际运行过程中，还会遇到很多在设计时未能考虑到的异常故障。所以，除非需求指标允许，在系统设计时不能放过任何异常情况。</p></li></ul><h3 id="分布式环境的各种问题"><a class="markdownIt-Anchor" href="#分布式环境的各种问题"></a> 分布式环境的各种问题</h3><p>分布式系统体系结构从其出现之初就伴随着诸多的难题和挑战，本节将向读者简要的介绍分布式环境中一些典型的问题。</p><h4 id="通信异常"><a class="markdownIt-Anchor" href="#通信异常"></a> 通信异常</h4><p>从集中式向分布式演变的过程中，必然引入了网络因素，而由于网络本身的不可靠性，因此也引入了额外的问题。分布式系统需要在各个节点之间进行网络通信，因此每次网络通信都会伴随着网络不可用的风险。另外，即使分布式系统各节点之间的网络通信能够正常进行，其延时也会远大于单机操作。</p><h4 id="网络分区"><a class="markdownIt-Anchor" href="#网络分区"></a> 网络分区</h4><p>当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点之间能够进行正常通信，而另一些节点则不能–我们将这个现象称为网络分区，就是俗称的“脑裂”。当网络分区出现时，分布式系统会出现局部小集群，在极端情况下，这些局部小集群会独立完成原本需要整个分布式系统才能完成的功能，包括对数据的事务处理，这就对分布式一致性提出了非常大的挑战。</p><h4 id="三态"><a class="markdownIt-Anchor" href="#三态"></a> 三态</h4><p>分布式系统的每一次请求与响应，存在特有的“三态”概念，即成功、失败与超时。在传统的单机系统中，应用程序在调用一个函数之后，能够得到一个非常明确的响应：成功或失败。而在分布式系统中，由于网络是不可靠的，虽然在绝大多数情况下，网络通信也能够接收到成功或失败的响应，但是当网络出现异常的情况下，就可能会出现超时现象，通常有以下两种情况：</p><ul><li>由于网络原因，该请求(消息)并没有被成功地发送到接收方，而是在发生过程就发生了消息丢失现象。</li><li>该请求(消息)成功的被接收方接收后，并进行了处理，但是在响应反馈给发送方的过程中，发生了消息丢失现象。</li></ul><p>当出现这样的超时现象时，网络通信的发起方是无法确定当前请求是否被成功处理的。</p><h4 id="节点故障"><a class="markdownIt-Anchor" href="#节点故障"></a> 节点故障</h4><p>节点故障则是分布式环境下另一个比较常见的问题，指的是组成分布式系统的服务器节点出现的宕机或“僵死”现象。通常根据经验来说，每个节点都有可能会出现故障，并且每天都在发生。</p><h2 id="从acid到capbase"><a class="markdownIt-Anchor" href="#从acid到capbase"></a> 从ACID到CAP/BASE</h2><h4 id="acid"><a class="markdownIt-Anchor" href="#acid"></a> ACID</h4><p>事务是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元，狭义上的事务特指数据库事务。一方面，当多个应用程序并发访问数据库时，事务可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。另一方面，事务为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持数据一致性的方法。</p><p>事务具有四个特征，分别是原子性(<code>Atomicity</code>)、一致性(<code>Consistency</code>)、隔离性(<code>Isolation</code>)和持久性(<code>Durability</code>)，简称为事务的<code>ACID</code>特征。</p><h5 id="原子性"><a class="markdownIt-Anchor" href="#原子性"></a> 原子性</h5><p>事务的原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出现以下两种状态之一。</p><ul><li>全部成功执行。</li><li>全部不执行。</li></ul><p>任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成。</p><h5 id="一致性"><a class="markdownIt-Anchor" href="#一致性"></a> 一致性</h5><p>事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。也就是说，事务执行的结果必须是使数据库从一个一致性状态转变到另一个一致性状态，因此当数据库只包含成功事务提交的结果时，就能说数据库处于一致性状态。而如果数据库系统在运行过程中发生故障，有些事务尚未完成就被迫中断，这些未完成的事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是不一致的状态。</p><h5 id="隔离性"><a class="markdownIt-Anchor" href="#隔离性"></a> 隔离性</h5><p>事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。也就是说，不同的事务并发操纵相同的数据时，每个事务都有各自完整的数据空间，即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><h5 id="持久性"><a class="markdownIt-Anchor" href="#持久性"></a> 持久性</h5><p>事务的持久性也被称为永久性，是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的。换句话说，一旦某个事务成功结束，那么它对数据库所做的更新就必须被永久保存下来–即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。</p><h4 id="分布式事务"><a class="markdownIt-Anchor" href="#分布式事务"></a> 分布式事务</h4><p>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点之上。通常一个分布式事务中会涉及对多个数据源或业务系统的操作。</p><h4 id="cap和base理论"><a class="markdownIt-Anchor" href="#cap和base理论"></a> CAP和BASE理论</h4><p>在可用性和一致性之间永远无法存在一个两全其美的方案，于是如何构建一个兼顾可用性和一致性的分布式系统成为了无数工程师探讨的难题，出现了诸如<code>CAP</code>和<code>BASE</code>这样的分布式系统经典理论。</p><h5 id="cap定理"><a class="markdownIt-Anchor" href="#cap定理"></a> CAP定理</h5><p><code>CAP</code>理论告诉我们，一个分布式系统不可能同时满足一致性(<code>C: Consistency</code>)、可用性(<code>A: Availability</code>)和分区容错性(<code>P: Partition tolerance</code>)这三个基本需求，做多只能同时满足其中的两项。</p><p><img src="https://github.com/maoyunfei/static-sources/blob/master/cap_1.jpeg?raw=true" alt=""></p><p><img src="https://github.com/maoyunfei/static-sources/blob/master/cap_2.jpeg?raw=true" alt=""></p><p>从<code>CAP</code>定理中我们可以看出，一个分布式系统不可能同时满足一致性、可用性和分区容错性这三个需求。另一方面，需要明确的一点是，<strong>对于一个分布式系统而言，分区容错性可以说是一个最基本的要求</strong>。因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统架构设计师往往需要把精力花在如何根据业务特点在<code>C</code>(一致性)和<code>A</code>(可用性)之间寻求平衡。</p><h5 id="base理论"><a class="markdownIt-Anchor" href="#base理论"></a> BASE理论</h5><p><code>BASE</code>是<code>Basically Available</code>(基本可用)、<code>Soft state</code>(软状态)和<code>Eventually consistent</code>(最终一致性)三个短语的简写。<code>BASE</code>是对<code>CAP</code>中一致性和可用性权衡的结果，其核心来源于对大规模互联网系统分布式实践的总结，是基于<code>CAP</code>定理逐步演化而来的，其核心思想是即使无法做到强一致性，但每个业务都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p><p><strong>基本可用</strong></p><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性–但请注意，这绝不等价于系统不可用。以下两个就是“基本可用”的典型例子。</p><ul><li>响应时间上的损失。</li><li>功能上的损失。</li></ul><p><strong>弱状态</strong></p><p>弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><p><strong>最终一致性</strong></p><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证数据的强一致性。</p><p>总的来说，<code>BASE</code>理论面向的是大型高可用可扩展的分布式系统，和传统事务的<code>ACID</code>特性是相反的，他完全不同于<code>ACID</code>的强一致性模型，而是提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此具体分布式系统架构设计过程中，<code>ACID</code>特性与<code>BASE</code>理论往往又会结合在一起使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从集中式到分布式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#从集中式到分布式&quot;&gt;&lt;/a&gt; 从集中式到分布式&lt;/h2&gt;&lt;h3 id=&quot;集中式的特点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#集中式的特点&quot;&gt;&lt;/a&gt; 集中式的特点&lt;/h3&gt;&lt;p&gt;所谓的集中式系统就是指由一台或多台主计算机组成中心节点，数据集中存储于这个中心节点中，并且整个系统的所有业务单元都集中部署在这个中心节点上，系统的所有功能均由其集中处理。&lt;/p&gt;&lt;p&gt;集中式系统最大的特点就是部署结构简单。由于集中式系统往往基于底层性能卓越的大型主机，因此无需考虑如何对服务进行多个节点的部署，也就不用考虑多个节点之间的分布式协作问题。&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="https://maoyunfei.github.io/categories/distributed/"/>
    
    
      <category term="分布式" scheme="https://maoyunfei.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="ACID" scheme="https://maoyunfei.github.io/tags/ACID/"/>
    
      <category term="CAP" scheme="https://maoyunfei.github.io/tags/CAP/"/>
    
      <category term="BASE" scheme="https://maoyunfei.github.io/tags/BASE/"/>
    
  </entry>
  
</feed>
